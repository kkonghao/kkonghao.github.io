<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="土豆の博客" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="开头首先浅要介绍一下Intel CPU 的发展史吧：Intel CPU 系列，最初是4位微处理器4004，然后到到8位微处理器的8008，再到8微微处理器8080,以及稍后的16位微处理器8086，由8086开始，Intel进入现在所谓的  x86时代 。Intel 8086为16位CPU，而因为在8086之前的CPU都是8位CPU，这样也就造成了很多的外设也只支持8位，因此Intel紧接着就退出">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="8086CPU的一些认知">
<meta property="og:url" content="http:&#x2F;&#x2F;tingyuxuan.com&#x2F;2019&#x2F;11&#x2F;06&#x2F;8086CPU%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E7%9F%A5&#x2F;index.html">
<meta property="og:site_name" content="土豆の博客">
<meta property="og:description" content="开头首先浅要介绍一下Intel CPU 的发展史吧：Intel CPU 系列，最初是4位微处理器4004，然后到到8位微处理器的8008，再到8微微处理器8080,以及稍后的16位微处理器8086，由8086开始，Intel进入现在所谓的  x86时代 。Intel 8086为16位CPU，而因为在8086之前的CPU都是8位CPU，这样也就造成了很多的外设也只支持8位，因此Intel紧接着就退出">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116010431.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116134622.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116011129.png">
<meta property="og:image" content="http:&#x2F;&#x2F;tingyuxuan.com&#x2F;images&#x2F;2019&#x2F;11&#x2F;16&#x2F;0cbc8b60-07cb-11ea-9cf6-fb9e5c359a2c.png">
<meta property="og:image" content="http:&#x2F;&#x2F;tingyuxuan.com&#x2F;images&#x2F;2019&#x2F;11&#x2F;16&#x2F;2cd9d3d0-07cb-11ea-9cf6-fb9e5c359a2c.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116011343.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116011404.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116011455.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116011529.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116011649.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116011906.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116011938.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116011957.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116012102.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116012123.png">
<meta property="og:image" content="http:&#x2F;&#x2F;tingyuxuan.com&#x2F;images&#x2F;2019&#x2F;11&#x2F;16&#x2F;6639d390-07cc-11ea-9cf6-fb9e5c359a2c.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116012211.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116012252.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116012310.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116012327.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116012348.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116012411.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116012444.png">
<meta property="og:image" content="http:&#x2F;&#x2F;tingyuxuan.com&#x2F;images&#x2F;2019&#x2F;11&#x2F;16&#x2F;e404e3f0-07cc-11ea-9cf6-fb9e5c359a2c.png">
<meta property="og:image" content="http:&#x2F;&#x2F;tingyuxuan.com&#x2F;images&#x2F;2019&#x2F;11&#x2F;16&#x2F;eeafe890-07cc-11ea-9cf6-fb9e5c359a2c.png">
<meta property="og:image" content="http:&#x2F;&#x2F;tingyuxuan.com&#x2F;images&#x2F;2019&#x2F;11&#x2F;16&#x2F;01c02080-07cd-11ea-9cf6-fb9e5c359a2c.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116012635.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116012657.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116012722.png">
<meta property="og:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116012745.png">
<meta property="og:updated_time" content="2019-11-06T06:10:17.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;kankan-myblog.oss-cn-shenzhen.aliyuncs.com&#x2F;img&#x2F;20191116010431.png">

<link rel="canonical" href="http://tingyuxuan.com/2019/11/06/8086CPU%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E7%9F%A5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>8086CPU的一些认知 | 土豆の博客</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<a href="https://github.com/kkonghao" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z">
	</path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 
	C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,
	84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" 
	class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,
	60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">土豆の博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">14</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tingyuxuan.com/2019/11/06/8086CPU%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E7%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="嘿你的土豆">
      <meta itemprop="description" content="我的征途是星辰大海">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="土豆の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          8086CPU的一些认知
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-06 14:10:17" itemprop="dateCreated datePublished" datetime="2019-11-06T14:10:17+08:00">2019-11-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/11/06/8086CPU%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E7%9F%A5/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/11/06/8086CPU%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E7%9F%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h4><p>首先浅要介绍一下Intel CPU 的发展史吧：Intel CPU 系列，最初是4位微处理器4004，然后到到8位微处理器的8008，再到8微微处理器8080,以及稍后的16位微处理器8086，由8086开始，Intel进入现在所谓的  x86时代 。Intel 8086为16位CPU，而因为在8086之前的CPU都是8位CPU，这样也就造成了很多的外设也只支持8位，因此Intel紧接着就退出了8位的8088CPU，因此Intel 8088也就可以看做是8086的8位版本；如果是但从汇编语言的角度上来说，8086和8088是没有区别的，即8086上跑的程序可以不加修改的移植到 8088，8088上跑的程序也可以不加修改的移植到8086上，当然，还是有些特殊的地方是不同的，而这些基本上在这里可以忽略掉，在8088CPU 之后，Intel又推出了80186,80286，这两款CPU均是16位CPU，而对于80186来说，其与8086的区别可以简单的看做是80186多了几条指令而已，而80286则不同，80286的地址总线数目有了变化，在 8086, 8088, 80186上，CPU的地址总线都是20根，即可最大寻址达到1MB的寻址能力，而对于80286CPU来说，其地址总线数目达到了24根，从而最大寻址能力为16MB。</p>
<a id="more"></a>
<p>由于支持更多的物理内存寻址，因此80286便开始成为了多任务，多用户系统的核心。而后来，Intel又推出了80386，80386为32位微处理器，Intel 80x86家族的32位微处理器始于80386；同时80386也完全兼容先前的 8086/8088，80186，80286，并且80386全面支持32位数据类型和32位操作，并且80386的数据总线根数和地址总线根数均达到了32根，从而可以最大物理寻址为232即4GB 。</p>
<p>而之后的80486也是32位微处理器，而后又出来了Pentium和Pentium Pro等等第五代微处理器，这些处理器虽然也是32位微处理器，但是他们的数据总线和地址总线都有所扩展，比如 Pentium 的数据总线达到64位，而 Pentium Pro 的地址总线位数达到了36位 。好，关于Intel CPU的介绍就到这里了，下面就要开始回归中心，看CPU中的寄存器了，</p>
<p>首先，从学习的角度来说，从 8086/8088 CPU下手是不错的选择，而我这里选择的也是8086CPU而已，说实在的，像80386CPU我也还没有研究过，像奔腾这些，呵呵，扯更远了，说到底也就只能拿8086出来晒晒而已，当然，从8086开始也是学习的最佳路径 。</p>
<p>说了这么久，到底寄存器是什么呢？其实很简单，寄存器就是个存储信息的单元或者说是器件又或者说是容器而已，就比如内存也是一个存储介质或者说是存储单元而已，其实寄存器从理解上来说和内存差不多，只不过寄存器（这里讨论的寄存器都是CPU中的寄存器，不包括外设上的寄存器）位于CPU内部，而内存位于CPU外部，而且，寄存器比内存可是珍贵得多啊，就拿内存和硬盘来比，肯定是内存在使用上珍贵得多，是 PC 中的稀有资源，而寄存器是CPU中的稀有资源，内存和寄存器相比就像硬盘和内存相比一样 。而对于一个汇编程序员来说，CPU中主要可以使用的也就是寄存器而已，汇编程序员可以使用指令来读写CPU中的寄存器，从而可以实现对于CPU的控制，当然，不同的CPU，寄存器的个数和结构都是不一样的，比如8086CPU中，寄存器的个数也就14个而已，并且8086CPU中所有的寄存器的结构为16位，即一个寄存器中可以存放下2B即2个字节，而到了80386CPU中，寄存器的个数也比8086增多了，比如在80386中添加了系统地址寄存器等寄存器，同时寄存器的结构也变了，比如在80386中绝大多数的寄存器为32位，而有些寄存器则是16位 。</p>
<p>8086CPU 中寄存器总共为14个，且均为16位 。即AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES 共14个。而这14个寄存器按照一定方式又分为了通用寄存器，控制寄存器和段寄存器。</p>
<font face="楷体">通用寄存器</font>

<p>AX (Accumulator)：累加寄存器，也称之为累加器；<br>BX (Base)：基地址寄存器；<br>CX (Count)：计数器寄存器；<br>DX (Data)：数据寄存器；<br>AX，BX，CX，DX 称作为数据寄存器：</p>
<p>SP 和 BP 又称作为指针寄存器：<br>SP (Stack Pointer)：堆栈指针寄存器；<br>BP (Base Pointer)：基指针寄存器；</p>
<p>SI 和 DI 又称作为变址寄存器：<br>SI (Source Index)：源变址寄存器；<br>DI (Destination Index)：目的变址寄存器；</p>
<p>控制寄存器：IP (Instruction Pointer)：指令指针寄存器；<br>标志寄存器：FLAG</p>
<p><font face="楷体">段寄存器</font><br>CS (Code Segment)：代码段寄存器；<br>DS (Data Segment)：数据段寄存器；<br>SS (Stack Segment)：堆栈段寄存器；<br>ES (Extra Segment)：附加段寄存器；</p>
<h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>从上面可以知道，在 8086 CPU 中，通用寄存器有 8 个，分别是 AX，BX，CX，DX，SP，BP，SI，DI ，至于为什么给它们取名做通用寄存器，那是因为，这些个寄存器每一个都有自己专门的用途，比如 CX 作为计数寄存器，则是在使用 LOOP 指令循环时用来指定循环次数的寄存器，如果它们每一个都只有一个专用的作用，那就它们只能称之为专用寄存器了，正是因为这些个寄存器还可以用来传送数据和暂存数据，所以才称它们为通用寄存器 。下面就按顺序来一一介绍这几个通用寄存器了：</p>
<h5 id="数据寄存器（AX，BX，CX，DX）："><a href="#数据寄存器（AX，BX，CX，DX）：" class="headerlink" title="数据寄存器（AX，BX，CX，DX）："></a>数据寄存器（AX，BX，CX，DX）：</h5><p>数据寄存器有 AX，BX，CX，DX 四个组成，由于在8086之前的 CPU为 8 位 CPU，所以为了兼容以前的 8 位程序，在 8086 CPU 中，每一个数据寄存器都可以当做两个单独的寄存器来使用，由此，每一个 16 位寄存器就可以当做 2 个独立的 8 位寄存器来使用了 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AX 寄存器可以分为两个独立的 <span class="number">8</span> 位的 AH 和 AL 寄存器；</span><br><span class="line">BX 寄存器可以分为两个独立的 <span class="number">8</span> 位的 BH 和 BL 寄存器；</span><br><span class="line">CX 寄存器可以分为两个独立的 <span class="number">8</span> 位的 CH 和 CL 寄存器；</span><br><span class="line">DX 寄存器可以分为两个独立的 <span class="number">8</span> 位的 DH 和 DL 寄存器；</span><br></pre></td></tr></table></figure>
<p>除了上面4个数据寄存器以外，其他寄存器均不可以分为两个独立的8位寄存器；注意在上面标志中的“独立”二字，这两个字表明 AH 和 AL 作为 8 位寄存器使用时，可以看做它们是互不相关的，也就是看做两个完全没有联系的寄存器 X 和 Y 即可，比如指令MOV AH ,12H ，CPU 在执行时根本就不会知道 AL 中是什么鬼东西，因为它只认识 AH 。下面给出一幅 16 位数据寄存器的结构图：表示 16 位 寄存器 AX 可以表示成两个 8 位寄存器，其中 AH 表示高位的 8 位寄存器，AL 表示低位的 8 位寄存器 。</p>
<p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116010431.png" alt></p>
<h6 id="AX寄存器"><a href="#AX寄存器" class="headerlink" title="AX寄存器"></a>AX寄存器</h6><p>如上所说，AX 的另外一个名字叫做累加寄存器或者简称为累加器，其可以分为2个独立的 8位寄存器 AH 和 AL；在写汇编程序时，AX 寄存器可以说是使用率最高的寄存器（不过，总共才那么 14 个寄存器，哪一个不经常使用咯？），既然 AX 是数据寄存器的话，那么理所当然，其可以用来存放普通的数据，由于其是 16 位寄存器，自然也就可以存放16位数据，但是因为其又可以分为2个独立的8位寄存器AH和AL所以，在 AH 和AL中又可以独立的存放2个8位的数据，可以有以下代码（即将 AX 当做普通的寄存器使用，即可以用来暂存数据）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,<span class="number">1234</span>H	  ;向寄存器 AX 传入数据 <span class="number">1234</span>H</span><br><span class="line">MOV AH,<span class="number">56</span>H	  ;向寄存器 AX 的高 <span class="number">8</span> 位寄存器 AH 中传入数据 <span class="number">56</span>H</span><br><span class="line">MOV AL,<span class="number">78</span>H        ;向寄存器 AX 的低 <span class="number">8</span> 位寄存器 AL 中传入数据 <span class="number">78</span>H</span><br></pre></td></tr></table></figure>
<p>3条语句的执行过程如下：</p>
<p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116134622.png" alt></p>
<p>而既然 AX 又被称作为累加器，自然其还有一点点特殊的地方的：</p>
<p>一、AX 寄存器还具有的特殊用途是在使用DIV和MUL指令时使用，DIV在8086CPU中是除法指令，而在使用除法的时候有两种情况，即除数可以是8位或者是16位的，而且除数可以存放在寄存器中或者是内存单元中，而至于被除数的话，自然,应该由AX来代替了，当除数是8位时，被除数一定会是16位的，并且默认是放在AX寄存器中，而当除数是16位时，被除数一定是32位的，因为AX是16位寄存器，自然，放不下32位的被除数，所以，在这里还需要使用另一个16位寄存器DX，其中DX存放32位的被除数的高16位，而AX则存放32位的被除数的低16位，同时，AX的作用还不仅仅是用来保存被除数的，当除法指令执行完成以后，如果除数是8位的，则在AL中会保存此次除法操作的商，而在AH中则会保存此次除法操作的余数，当然，如果除数是16位的话，则AX中会保存本次除法操作的商，而DX则保存本次除法操作的余数。</p>
<p>二、上面介绍的是 AX 寄存器在除法操作中的应用，下面还需要介绍一下 AX 在乘法操作中的应用，当使用 MUL 做乘法运算时，两个相乘的数要么都是8位，要么都是16位，如果两个相乘的数都是8位的话，则一个默认是放在AL中，而另一个8位的乘数则位于其他的寄存器或者说是内存字节单元中，而如果两个相乘的数都是16位的话，则一个默认存放在AX中，另一个16位的则是位于16的寄存器中或者是某个内存字单元中。同时，当MUL指令执行完毕后，如果是8位的乘法运算，则默认乘法运算的结果是保存在AX中，而如果是16位的乘法运算的话，则默认乘法运算的结果有32位，其中，高位默认保存在DX中，而低位则默认保存在AX中。</p>
<p>AX 寄存器在DIV指令中的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV DX,<span class="number">0</span>H		;设置 <span class="number">32</span> 位被除数的高 <span class="number">16</span> 位为 <span class="number">0</span>H</span><br><span class="line">MOV AX,<span class="number">8</span>H		;设置 <span class="number">32</span> 位被除数的低 <span class="number">16</span> 位为 <span class="number">8</span>H</span><br><span class="line">MOV BX,<span class="number">2</span>H		;设置 <span class="number">16</span> 位除数为 <span class="number">2</span>H</span><br><span class="line">DIV BX		        ;执行计算</span><br></pre></td></tr></table></figure>
<p>4 条语句的执行过程如下：</p>
<p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011129.png" alt></p>
<p>AX 寄存器在 MUL  指令中的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,<span class="number">800</span>H		;设置 <span class="number">16</span> 位乘数为 <span class="number">800</span>H</span><br><span class="line">MOV BX,<span class="number">100</span>H		;设置 <span class="number">16</span> 位乘数为 <span class="number">100</span>H</span><br><span class="line">MOV DX,<span class="number">0</span>H		;清空用来保存乘法结果的高 <span class="number">16</span> 位    </span><br><span class="line">MUL BX		        ;执行计算</span><br></pre></td></tr></table></figure>
<p>4 条语句的执行过程如下：</p>
<p><img src="/images/2019/11/16/0cbc8b60-07cb-11ea-9cf6-fb9e5c359a2c.png" alt="image.png"></p>
<h6 id="BX-寄存器"><a href="#BX-寄存器" class="headerlink" title="BX 寄存器"></a>BX 寄存器</h6><p>首先可以明确的是，BX作为数据寄存器，表明其是可以暂存一般的数据的，即在某种程度上，它和AX可以暂存一般性数据的功能是一样的，其同样为了适应以前的8位CPU，而可以将BX当做两个独立的8位寄存器使用，即有BH和BL，除了暂存一般性数据的功能外，BX作为通用寄存器的一种，BX主要还是用于其专属功能—寻址（寻址物理内存地址）上，BX 寄存器中存放的数据一般是用来作为偏移地址使用的，何为偏移地址呢？</p>
<p>既然是偏移地址的话，当然得有一个基地址了，而这个基地址其实就是段地址，这里就涉及到了段寄存器，当然，在介绍 BX 寄存器的时候，我不会去介绍段寄存器，上面提到 BX 的主要功能是用在寻址上，那么，其是如何寻址的呢？</p>
<p>对于寻址这个话题，我会在我的下一篇博文中作出详细的介绍，而这里，我只点一下，在8086 CPU中，CPU 是根据 &lt;段地址：偏移地址&gt; 来进行寻址操作的，而BX中存放的数据表示的是偏移地址的话，自然，便可以通过 &lt;段地址：[BX]&gt; 的方式来完成寻址操作了。</p>
<p>为了介绍BX在寻址当中的作用，下面我给出一副示意图：</p>
<p><img src="/images/2019/11/16/2cd9d3d0-07cb-11ea-9cf6-fb9e5c359a2c.png" alt="image.png"></p>
<p>上面的示意图表示：可以令 BX = 2，然后通过DS : [BX] 来访问到内存中段地址为DS，且偏移量为2的内存单元了。</p>
<p>上面介绍的这种寻址方式是 BX 在寻址中最最简单的应用了，而对于稍微复杂的寻址方式，还可以依赖于 SI，DI，BP 等寄存器来一起完成，当然，这会是下一篇博文将要介绍的内容了。</p>
<p>BX寄存器在寻址中的使用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV BX,<span class="number">5</span>H</span><br><span class="line">MOV AH,<span class="number">11</span>H</span><br><span class="line">MOV AH,[BX]		;设置 AX 的值为偏移地址为 BX 中的值时所代表的内存单元</span><br></pre></td></tr></table></figure>
<p>3 条语句的执行过程如下：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011343.png" alt></p>
<p>从上图可以看出，在偏移地址为 5 时的内存单元中的数据位 BBH，<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011404.png" alt><br>而从这幅图上面就可以看出，确实通过 [BX] 找到了偏移地址为 5 处的内存单元，并且将内存单元移入了 AH 中。</p>
<h6 id="CX-寄存器"><a href="#CX-寄存器" class="headerlink" title="CX 寄存器"></a>CX 寄存器</h6><p>CX寄存器作为数据寄存器的一种呢，其同样具有和AX,BX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的8位寄存器使用，即有CH和CL两个8位寄存器，当然，CX也是有其专门的用途的，CX 中的C被翻译为Counting也就是计数器的功能，当在汇编指令中使用循环LOOP指令时，可以通过CX来指定需要循环的次数，而CPU在每一次执行LOOP指令的时候，都会做两件事：一件就是令CX=CX–1，即令CX 计数器自动减去1；还有一件就是判断CX中的值，如果CX中的值为0则会跳出循环，而继续执行循环下面的指令，当然如果CX中的值不为0，则会继续执行循环中所指定的指令 。</p>
<p>CX 寄存器在循环中的使用（输出5个白底蓝字的A）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,<span class="number">0B</span>800H</span><br><span class="line">MOV DS,AX		    ;使用 <span class="number">80</span>x25 彩色字符模式，内存地址 <span class="number">0xB8000</span> - <span class="number">0xBFFFFF</span></span><br><span class="line">MOV BX,<span class="number">0</span>		    ;从 <span class="number">0xB8000</span> 开始</span><br><span class="line">MOV CX,<span class="number">5</span>H		    ;循环 <span class="number">5</span> 次</span><br><span class="line">MOV DX,<span class="number">41</span>H		    ;A 的<span class="number">16</span> 进制为 <span class="number">41</span>H</span><br><span class="line">MOV AX,<span class="number">01110001B</span>	;显示白底蓝字</span><br><span class="line">s:  MOV [BX],DX	;显示 ASCII 字符</span><br><span class="line">    ADD BX,<span class="number">1</span></span><br><span class="line">    MOV [BX],AX	;设置字符显示属性</span><br><span class="line">    ADD BX,<span class="number">1</span></span><br><span class="line">LOOP s</span><br></pre></td></tr></table></figure>
<p>语句的执行过程如下：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011455.png" alt></p>
<h6 id="DX-寄存器"><a href="#DX-寄存器" class="headerlink" title="DX 寄存器"></a>DX 寄存器</h6><p>DX 寄存器作为数据寄存器的一种，同样具有和 AX，BX，CX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的8位寄存器使用，极有DH和 DL，同时，DX 作为一个通用寄存器的话，自然其还有其他的用途，而关于DX在其他方面的用途，其实在前面介绍AX寄存器时便已经有所介绍了，即当在使用 DIV 指令进行除法运算时，如果除数为16位时，被除数将会是32位，而被除数的高16位就是存放在 DX 中，而且执行完 DIV 指令后，本次除法运算所产生的余数将会保存在DX中，同时，在执行 MUL 指令时，如果两个相乘的数都是 16 位的话，那么相乘后产生的结果显然需要32位来保存，而这32位的结果的高16位就是存放在 DX 寄存器中。</p>
<p>DX寄存器在DIV指令中的使用（即2293812 / 256 = 8960  余数为52）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV DX,<span class="number">0023</span>H	;<span class="number">32</span> 位被除数的高 <span class="number">16</span> 位</span><br><span class="line">MOV AX,<span class="number">0034</span>H	;<span class="number">32</span> 位被除数的低 <span class="number">16</span> 位</span><br><span class="line">MOV BX,<span class="number">100</span>H	;<span class="number">16</span> 的除数</span><br><span class="line">DIV BX</span><br></pre></td></tr></table></figure>
<p>语句的执行过程如下：</p>
<p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011529.png" alt></p>
<p>可以看到在语句结束以后，AX = 2300H  即十进制的 8960，而 DX = 34H即十进制的 52 和我们的结果是一致的。</p>
<p>DX 寄存器在 MUL  指令中的使用则各位可以参考在 AX 中 MUL 运算的使用，这里就不贴出来了。</p>
<h5 id="指针寄存器（BP，SP）"><a href="#指针寄存器（BP，SP）" class="headerlink" title="指针寄存器（BP，SP）"></a>指针寄存器（BP，SP）</h5><h6 id="BP-寄存器："><a href="#BP-寄存器：" class="headerlink" title="BP 寄存器："></a>BP 寄存器：</h6><p>8086  CPU 中的指针寄存器包括两个，即 SP 和 BP ，在这里呢，我先只对 BP 寄存器做介绍，因为 SP 寄存器实质上必须和 SS 段寄存器一起使用，所以，我将会把 SP 寄存器留到后面和 SS 段寄存器一起作介绍。</p>
<p>BP (Base Pointer)也就是基指针寄存器，它和其他的几个用来进行寻址操作所使用的寄存器（还有 BX，SI，DI）没有太大的区别，</p>
<p>关于 SI 和 DI 寄存器的下面请见下文。</p>
<p>首先，BP 寄存器作为通用寄存器的一种，说明其是可以暂存数据的，而后，BP 又不是数据寄存器，也就意味着其不能分割成 2 个独立的 8 位寄存器使用，而后当以 […] 的方式访问内存单元而且在 […] 中使用了寄存器 BP 的话，那么如果在指令中没有明确或者说是显示的给出段地址时，段地址则使用默认的 SS 寄存器中的值（BX，SI，DI 会默认使用 DS 段寄存器），比如 DS:[BP] 则在这里明确给出了段地址位于 DS 中，所以，这里代表的内存单元即是段地址为 DS ，偏移量为 BP 寄存器中的值的内存单元，而如果单单是使用 [BP] 的话，则代表的内存单元是段地址为 SS，偏移量为 BP 寄存器中的值的内存单元。</p>
<p>并且 BP 寄存器主要适用于给出堆栈中数据区的偏移，从而可以方便的实现直接存取堆栈中的数据，至于堆栈的话，会在后面的博文中介绍。在 8086 CPU 中，只有 4 个寄存器可以以  […]  的方式使用，这四个寄存器分别是 BX，SI，DI，BP。</p>
<p>下面的  Demo  是 BX 寄存器在寻址中的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV BP,<span class="number">0</span></span><br><span class="line">MOV AX,[BP]         ;将 SS:[BP] 代表的内存单元移入 AX 中</span><br><span class="line">MOV AX,CS:[BP]      ;将 CS:[BP] 代表的内存单元移入 AX 中</span><br></pre></td></tr></table></figure>
<p>语句的执行过程如下：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011649.png" alt></p>
<h5 id="变址寄存器（SI，DI）"><a href="#变址寄存器（SI，DI）" class="headerlink" title="变址寄存器（SI，DI）"></a>变址寄存器（SI，DI）</h5><p>首先，变址寄存器和上面介绍的指针寄存器（也就是 BP 和 SP），它们的功能其实都是用于存放某个存储单元地址的偏移，或者是用于某组存储单元开始地址的偏移，即作为存储器指针使用，当然，由于变址寄存器和指针寄存器都是属于通用寄存器，所以它们也可以保存算术结果或者说是具有暂存数据的功能，但是因为它们不是数据寄存器，所以无法分割成 2 个独立的 8 位寄存器使用。</p>
<p>关于变址寄存器和指针寄存器的详细使用，笔者将会在下一篇博文中作出最详细的介绍，</p>
<p>SI (Source Index) 是源变址寄存器，DI (Destination Index) 即是目的变址寄存器，8086 CPU 中的 SI 寄存器和 DI 寄存器其实和 BX 寄存器的功能是差不多的，只不过 SI 寄存器和 DI 寄存器均不是数据寄存器，所以它们不能够拆分为 2 个独立的 8 位寄存器，而这也就是 SI 寄存器和 DI 寄存器与BX 寄存器所不同的地方，既然，SI，DI 两个寄存器的功能和 BX 差不多，自然，SI 和 DI 中也是可以暂存一般性数据的，同时，通过使用 SI 和 DI 寄存器也是可以用来完成寻址操作的。</p>
<p>比如下面的代码就是可行的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MOV SI,<span class="number">0</span>		;初始化偏移地址为 <span class="number">0</span></span><br><span class="line">MOV AX,[SI]		;将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,DS:[SI]		;将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,SS:[SI]		;将段地址为 SS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br><span class="line"></span><br><span class="line">MOV DI,<span class="number">0</span>    		;初始化偏移地址为 <span class="number">0</span></span><br><span class="line">MOV AX,[DI]		;将段地址为 DS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,DS:[DI]		;将段地址为 DS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,SS:[DI]		;将段地址为 SS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br></pre></td></tr></table></figure>
<h5 id="其他寄存器（CS，IP，SS，SP，DS，ES）"><a href="#其他寄存器（CS，IP，SS，SP，DS，ES）" class="headerlink" title="其他寄存器（CS，IP，SS，SP，DS，ES）"></a>其他寄存器（CS，IP，SS，SP，DS，ES）</h5><p>由于段寄存器总是和其他一些像指针寄存器，变址寄存器，控制寄存器一起使用，所以在这里，我并不会单独介绍段寄存器，而是将段寄存器和一些其他的常用寄存器搭配介绍 。由于下面的介绍中会涉及到很多关于段和栈的概念，而段和栈的介绍又都必须关系到物理内存，所以在介绍段寄存器以及其他一些呈协作关系的寄存器之前，还是先来介绍一下这几个基本的概念比较好。</p>
<p>8086 CPU 访问内存（物理地址）：</p>
<p>当 CPU 需要访问一个内存单元时，需要给出内存单元的地址，而每一个内存单元在物理内存空间中都有一个唯一的地址，即可以通过这个地址定位到内存单元，而这个地址即为物理地址。CPU 通过地址总线将一个内存单元的物理地址送入存储器，而后 CPU 便可以通过这个物理地址来访问这个物理地址所指向的内存单元了。</p>
<p>那么这个物理地址在 CPU 中是如何形成的呢？<br>首先，我们知道 8086 CPU 的地址总线是 20 根，即每次都可以传输 20 位的地址，从而寻址能力有 220 也就是 1MB 的大小，但是 8086 CPU 的寄存器只有 16 位，也就是在 8086 CPU 的内部，一次性处理，传输，暂存的地址都只能是 16 位，即 8086 CPU 不能完整的保存下一个物理地址（物理地址为 20 位），如果单单以最简单的方式（即直接用 16 位寄存器来保存物理地址）的话，那么，寻址能力只有 216 ，也就是 64KB，如果真以如此简单的方式的话，那么地址总线还需要 20 根干嘛呢？而且，难不成我们以后的内存就是 64KB 了吗？</p>
<p>当然不是的，8086 CPU 在这里采取了一定的措施从而使其寻址能力达到 1MB 。8086 CPU 在内部通过两个 16 位的地址进行合成从而形成一个 20 位的物理地址，由此，8086 CPU 的寻址能力便可以达到 1MB 。那么 8086 CPU 又是如何将两个 16 位的地址合成为一个20 位的物理地址的呢？当 CPU 在访问内存时，其会使用一个 16 位的基地址，然后再使用一个 16 位的偏移地址，通过将基地址和偏移地址传入 8086  CPU 的地址加法器中进行合成即可以构造出 20 位的物理地址。</p>
<p>至于合成的方式如下：</p>
<p>基地址其实是通过一个 16 位的段地址来形成的，将一个段地址左移 4 位即形成了基地址，而至于偏移地址的话，自然不必多说，为 16 位，通过将基地址和偏移地址相加便形成了 20 位的物理地址 。</p>
<p>下面给出一幅示意图来表示物理地址的合成：</p>
<p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011906.png" alt></p>
<p>段：</p>
<p>至于段的话，其实在物理内存中是没有段这一概念的，事实上，段的概念来自于  CPU ，因为 CPU 拥有段寄存器，既然在 CPU 中拥有了段寄存器，自然，在 CPU 中就肯定有段的概念了，其实段也就是在编程时，我们将若干个地址连续的内存单元看做是一个段，然后通过将一个段地址左移 4 位形成基地址，再通过这个基地址来定位这个段的起始地址，然后，再通过偏移地址便可以精确定位到段中的内存单元了，由于段的起始地址是一个段地址左移 4 位，所以很明显，段的起始地址肯定是 16 的倍数，而且由于一个段内部，只能通过偏移地址来定位，而偏移地址为 16 位，所以一个段的长度也就是 216 也就是 64KB 的大小。</p>
<p>在编程时，可以讲一段内存定义成为一个段，而这里，我们又可以引出数据段，代码段，栈段这三种类型的段 。</p>
<p>何为数据段呢？其实就是我们自个儿定义一段内存（当然段起始地址肯定是 16 的倍数，并且段长度 &lt;= 64KB），然后我们在这个段里头存放我们所需要使用的数据，这就是数据段；</p>
<p>何为代码段呢？其实也很简单，也是我们自己在编程的时候定义一段内存，然后这段内存用来存放我们的代码（也就是指令），</p>
<p>既然是存放的代码，自然就称之为代码段；</p>
<p>何为栈段呢？至于栈段的话，有接触过数据结构的朋友应该是很清楚栈的，而这里我们也就是在内存中分配出一个段，</p>
<p>然后将这个段当做栈来使用，对于栈的介绍，详见下文；</p>
<p>这里呢，顺便还点出几个关于段寄存器的内容，当然下文还会详细介绍的，</p>
<p>首先，对于任何一个段来说，均有段地址，而这些段地址是存放在段寄存器中（段寄存器的作用也在于此），但是对于不同的段，它们默认的段地址存放在不同的段寄存器中，像数据段来说，它的段地址存放在  DS （Data  Segment）寄存器中，代码段的段地址存放在  CS （Code  Segment）寄存器中，栈段的段地址存放在  SS （Stack  Segment）寄存器中 。</p>
<p>下面给出一幅在段中寻址的示意图：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011938.png" alt></p>
<p>上面的示意图中，通过将段地址左移四位，然后与偏移地址相加便可以得到 20 位的物理地址了 。</p>
<p>栈：</p>
<p>8086CPU中提供了对栈的支持，并且其还提供了相应的指令来以栈的方式访问内存空间 。</p>
<p>什么是栈？</p>
<p>通过上面在段中的介绍，栈其实就是一个段，再说白一点，也就是一块内存，当然，这块内存是一块连续的内存 。既然栈是一个段的话，那么当然就可以以使用段的方式来使用栈，当然，除了像段一样的使用栈以外，栈还提供了其特殊的访问方式（如果和段一模一样的话，那还需要栈干吗呢？），</p>
<p>众所周知，栈是先进后出类型的数据结构，在 8086  CPU 中也是如此，可以通过 ”PUSH“  指令将数据压入栈中，然后再通过 ”POP“  指令将栈顶的元素取出来 。</p>
<p>下面给出一幅示意图来描述栈：</p>
<p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011957.png" alt></p>
<p>即通过 PUSH  10 来将元素 10 放入栈中，因为，先前栈中没有任何数据，所以，10 就会作为栈顶元素存在，然后再在栈中压入元素 20 ，此时，栈顶中的元素就是 20 了，然后再使用  POP 指令将栈顶元素取出，此时取出的栈顶元素是 20 ，取出 20 后，栈中便只剩下 10 了，自然 10 就成为了栈顶，最后再通过 POP 指令将栈顶 10 取出，此时，栈便变成了空栈了 。</p>
<p>好了，在介绍段寄存器之前的基础知识介绍就到这里了，下面开始正式介绍段寄存器以及与它们协作使用的寄存器。</p>
<p>CS 寄存器 和 IP 寄存器：</p>
<p>经过前面对段的介绍，相信各位朋友对段寄存器应该也有一定的了解了，下面将要介绍的是一组非常非常重要的寄存器，即 CS:IP 。CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址，其中  CS  为代码段寄存器，而IP为指令指针寄存器 。</p>
<p>什么叫做指示了 CPU 当前将要读取的指令呢？在 8086  CPU 中，为什么  CPU  会自动的执行指令呢？<br>这些指令肯定是存放在内存中的，但是  CPU  怎么知道这些指令存放在内存的那个位置呢？<br>比如，我有下面的两条指令要执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,<span class="number">1234</span>H</span><br><span class="line">MOV BX,AX</span><br></pre></td></tr></table></figure>
<p>而假设这两条指令在内存中存放为：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012102.png" alt></p>
<p>很显然，1000H:0000H 指向的是MOV AX，1234H的首地址，如果CPU要读取到我的指令的话，很显然，必须要知道地址1000H:0000H，然后CPU就可以根据这个首地址，将汇编指令MOV  AX，1234H所对应的机器码读入到CPU的指令寄存器中，最后便可以在CPU中进行处理了。</p>
<p>但关键是CPU如何知道我的1000H:0000H这个首地址？</p>
<p>其实这就需要使用到CS:IP这个寄存器组了。当我们运行一个可执行文件时，很明显，我们需要另外一个程序来将这个可执行文件加载到内存当中，关于这个加载可执行文件的程序，我们在这里不管他，点一下即可，一般是通过操作系统的外壳程序（也就是传说中的Shell程序），Shell将可执行文件加载到内存中以后，就会设置CPU中的两个寄存器，即设置CS:IP两个寄存器指向可执行文件的起始地址，此后CPU便从这个起始地址开始读取内存中的指令，并且执行，比如我们在写汇编程序时，通常会使用START标记，其实这个标记就是用来标记起始地址的，当将一个汇编程序编译，连接成可执行文件以后，再通过操作系统的  Shell程序将可执行文件加载到内存中以后，这个START所标记处的地址就是整个可执行文件的起始地址了 。</p>
<p>也就是说，当一个可执行文件加载到内存中以后，CS:IP  两个寄存器便指向了这个可执行文件的起始地址，然后  CPU  就可以从这个起始地址开始往下读取指令，当读取完指令后，CS:IP  将会自动的改变，基本上是改变  IP ，从而指向下一条要读取的指令，这样就可以执行这个可执行文件了 。</p>
<p>最后再对  CS:IP  总结一下：</p>
<p>你想让CPU执行哪行指令，你就让CS:IP指向保存有指令的那块内存即可。任何时候，CS:IP指向的地址中的内容都是CPU当前执行的指令。下面我们来看一个Demo，并详细观察其执行的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">	</span><br><span class="line">START:</span><br><span class="line">    </span><br><span class="line">    MOV AX,<span class="number">1234</span>H</span><br><span class="line">    MOV BX,AX</span><br><span class="line">    </span><br><span class="line">    MOV AH,<span class="number">4</span>CH</span><br><span class="line">    INT <span class="number">21</span>H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure>
<p>语句的执行过程如下：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012123.png" alt></p>
<p>从上面的截图中可以看出，当我使用Shell（在DOS下也就是Command命令解释器）将可执行文件加载进内存后，可以看到，整个程序的起始地址为0C54H:0000H，并且，可以看到CS的地址为0C54H，IP的地址为0000H，这正好吻合我们上面对CS:IP的分析，很明显，CPU将会读取MOV AX，1234H 到CPU中并且执行 ，然后我们继续向下看：</p>
<p><img src="/images/2019/11/16/6639d390-07cc-11ea-9cf6-fb9e5c359a2c.png" alt="image.png"></p>
<p>可以看到，我们单步执行后，AX中的值编成了1234H，而IP寄存器中的值变成了0003H，对于AX中的值的改变，我们是能够理解的，但是IP中的值为什么会从0000H变到0003H呢？</p>
<p>从最上面的一幅关于指令在内存中的存放可以看出MOV AX,1234H在内存中需要3个内存单元存放，也就是  CPU为了执行MOV AX，1234H这条指令，已经将内存中相对应的3个内存单元读入内存中了，执行完这条指令后，自然，CPU就要将偏移地址向下移动3个单元，从而使得CS:IP指向下一条需要执行的指令了，为了更深刻的理解，我们再来继续看执行过程，</p>
<p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012211.png" alt></p>
<p>从最上面的一幅关于指令在内存中的存放可以看出MOV BX，AX在内存中只占2个内存单元，这也就是为什么IP这一次只向下移动了2个单元的缘故 。</p>
<p>关于CS:IP的遐想：</p>
<p>从上面关于CS:IP的介绍中，我们可以大胆的猜想，我们只需要通过手动的改变CS:IP所指向的内存地址，让CS:IP指向我们另外的代码，那么我们就可以让CPU执行我们自己指定的代码了 。即可以通过修改  CS:IP来达到我们想要让CPU干什么它就干什么的目的 。上面的虽然是遐想，但是大家要相信，我们写的是汇编，不是JAVA也不是NET，所以我们还真的可以达到上面的目的，也就是说我们的遐想其实是可以实现的，当然这还是有一定的限制的，关于这个遐想呢，可能会在我后续的博文中有所介绍，不过感兴趣的当然可以自己去尝试了，蛮有味的哦。</p>
<p>SS寄存器和SP寄存器：</p>
<p>根据前面对栈的介绍，相信各位对栈也肯定是有一定了解了的，更何况，估计大家也是职场打滚多年的，要是栈都没用过的话，那也确实蛮悲剧的 ，所以，我在这里也不会对栈做十分详细的介绍了，但是，最基本的介绍还是要的，毕竟在底层的话，不像高级语言那么方便，可以直接一个  Stack  就 OK 的，在底层涉及的是栈在内存中的具体实现 。</p>
<p>不知道，大伙有没有注意笔者在本篇博文的上面介绍关于栈的知识时，我并没有提到如何找到这个栈，我只提到了一个栈就是先进后出操作，同时可以使用”PUSH”和”POP”指令，然后就是稍微带了一下SS这个寄存器的介绍，</p>
<p>我们虽然在内存中是可以方便的定义一个栈了，但是，我们为什么要定义这么一个栈呢？自然，是为了操作方便，同时提供给CPU使用的，既然CPU要使用的话，自然，CPU又必须根据一定的方式找到这个栈，而这就需要使用SS和SP寄存器了 。</p>
<p>同时，一个栈也就是一块内存区域，通过上面的介绍，我们也知道了如果要在一块内存中精确地定位到内存单元的话（寻址），我们必须要有基地址（也就是段地址左移4位）和偏移地址，自然，要在一个栈中寻址的话，也需要段地址和偏移地址，</p>
<p>而对于一个栈来说，我们使用的最多的是什么呢？</p>
<p>当然是栈顶了，因为只有栈顶可以用来存取数据，所以对于一个栈来说，我们只需要有栈顶的段地址和偏移地址即可，而对于栈顶的段地址，其是存放在段寄存器SS中的，而对于栈顶的偏移地址，其则是存放在SP  寄存器中的。记住，在任何时刻，SS:SP都是指向栈顶元素。其实关于栈的使用还是比较简单的，但是要注意的是8086CPU并不会保证我们对栈的操作会不会越界。所以我们在使用栈的时候需要特别注意栈的越界问题 。</p>
<p>当使用  PUSH 指令向栈中压入1个字节单元时，SP = SP - 1；即栈顶元素会发生变化；而当使用PUSH指令向栈中压入2个字节的字单元时，SP = SP – 2 ；即栈顶元素也要发生变化；当使用POP指令从栈中弹出 1个字节单元时， SP = SP + 1；即栈顶元素会发生变化；当使用POP指令从栈中弹出2个字节单元的字单元时，SP = SP + 2；即栈顶元素会发生变化；</p>
<p>下面通过一个  Demo 来介绍栈的使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">	</span><br><span class="line">START:</span><br><span class="line">    </span><br><span class="line">    MOV AX,<span class="number">1000</span>H		;首先是定义好栈的段地址</span><br><span class="line">    MOV SS,AX    </span><br><span class="line">    MOV AX,<span class="number">10</span>H			;再定义好栈的长度（初始时刻的栈顶偏移地址即栈的长度）</span><br><span class="line">    MOV SP,AX</span><br><span class="line">    </span><br><span class="line">    MOV AX,<span class="number">0001</span>H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,<span class="number">0002</span>H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,<span class="number">0003</span>H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,<span class="number">0004</span>H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,<span class="number">0005</span>H</span><br><span class="line">    PUSH AX</span><br><span class="line">    </span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    MOV AH,<span class="number">4</span>CH</span><br><span class="line">    INT <span class="number">21</span>H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure>
<p>然后我们来看栈在内存中的结构图：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012252.png" alt><br>语句的执行过程如下：</p>
<p>首先我们来看尚未执行上述任何指令时栈中的数据情况：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012310.png" alt><br>然后我们再来依次执行上述指令：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012327.png" alt><br>从上副截图中可以看出已经设置好了  SS:SP ，也就是栈已经设置 OK 了，下面开始往栈中压入数据了，<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012348.png" alt><br>由于我们压入栈中的数据为字数据，即占 2 个内存单元，所以，每次  SP = SP – 2 ；将 5 个字型数据压入栈中后，我们可以来查看栈中的数据了，<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012411.png" alt><br>因此，在内存中的一个好看点的结构图如下所示：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012444.png" alt><br>下面开始进行出栈操作了<br><img src="/images/2019/11/16/e404e3f0-07cc-11ea-9cf6-fb9e5c359a2c.png" alt="image.png"><br>由于我们弹出栈时的数据为字数据，即占2个内存单元，所以，每次  SP = SP + 2 ；</p>
<p>将5个字型数据全部弹出栈中后，我们可以来查看栈中的数据了，<br><img src="/images/2019/11/16/eeafe890-07cc-11ea-9cf6-fb9e5c359a2c.png" alt="image.png"></p>
<p>可以看到 SP 变成了初始状态了，也就是说栈中所有的数据已经全部弹出了，虽然我们查看内存时看到的不是 0 ，</p>
<p>但是我们看到的这些数据都是无效的，我们这里不理会 。</p>
<p>DS 寄存器和 ES 寄存器：</p>
<p>DS寄存器和ES寄存器都属于段寄存器，其实它们和CS寄存器以及SS寄存器用起来区别不大，既然是段寄存器的话，自然它们存放的就是某个段地址了 。</p>
<p>通过上面对基础知识的介绍呢，我们已经知道，如果CPU要访问一个内存单元时，我们必须要提供一个指向这个内存单元的物理地址给CPU，而我们也知道在8086CPU中，物理地址是由段地址左移4位，然后加上偏移地址形成的，所以，我们也就只需要提供段地址和偏移地址即OK 。</p>
<p>8086CPU呢，提供了一个DS寄存器，并且通常都是通过这个DS段寄存器来存放要访问的数据的段地址 。</p>
<p>DS（Data  Segment）：很显然，DS中存放的是数据段的段地址 。</p>
<p>但是这里不得不再点一下，那就是我们对段的支持是在CPU上体现的，而不是在内存中实现了段，所以事实上我们使用的段其实是一个逻辑概念，即是我们自己定义的，再说白了，我定义一个段，我说它是数据段那它就是数据段，我说它是代码段那么它就是代码段，它们其实都是一块连续的内存而已，至于为什么要区分为数据段和代码段，很明显，是用来给我们编程提供方便的，即我们在自己的思想上或者说是编码习惯上规定，</p>
<p>数据放数据段中，代码放代码段中 。而我们在使用数据段的时候，为了方便或者说是代码的编写方便起见，我们一般把数据段的段地址放在DS寄存器中，当然，如果你硬要觉得DS不顺眼，那你可以换个ES也是一样的，至于ES（Extra  Segment）段寄存器的话，自然，是一个附加段寄存器，如果再说得过分点，就当它是个扩展吧，当你发现，你几个段寄存器不够用的时候，你可以考虑使用ES段寄存器，在使用方式上，则和其他的段寄存器没什么区别  。</p>
<p>下面看一个介绍使用DS寄存器的Demo：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">   </span><br><span class="line">START:</span><br><span class="line"></span><br><span class="line">    MOV AX,<span class="number">1000</span>H</span><br><span class="line">    MOV DS,AX</span><br><span class="line">    MOV AL,<span class="number">1</span></span><br><span class="line">    MOV BX,<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    MOV CX,<span class="number">5</span>			;设计一个循环，让其循环 <span class="number">5</span> 次</span><br><span class="line">    s: MOV [BX],AL		;这里 [BX] 并没有指定段地址哦</span><br><span class="line">       INC AL</span><br><span class="line">       INC BX</span><br><span class="line">       LOOP s            </span><br><span class="line">    </span><br><span class="line">    MOV AH,<span class="number">4</span>CH</span><br><span class="line">    INT <span class="number">21</span>H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure>
<p>上面的代码所做的事情，就是循环将1，2，3，4，5写入到地址1000H：0000H ，1000H：0001H，1000H：0002H，1000H：0003H，1000H：0004H  中，</p>
<p>语句的执行过程如下：</p>
<p>首先我们来看尚未执行上述任何指令时栈中的数据情况：<br><img src="/images/2019/11/16/01c02080-07cd-11ea-9cf6-fb9e5c359a2c.png" alt="image.png"></p>
<p>而当循环执行完成以后，我们再来看内存  1000H：0000H 处的值：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012635.png" alt><br>在这里，我们可以看到确实达到了我们预期的效果，但是大家注意看代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s: MOV [BX],AL		;这里 [BX] 并没有指定段地址哦</span><br><span class="line">    INC AL</span><br><span class="line">   INC BX</span><br><span class="line">   LOOP s</span><br></pre></td></tr></table></figure></p>
<p>这里可以看到，我们在[BX]  中并没有给其指定段地址，而只有一个偏移地址，但是根据我们一开始的介绍，必须要有段地址和偏移地址才能够定位内存单元，莫非这里出问题了？其实不是的，因为我们在最前面定义了段地址DS为1000H，当我们定义好段地址后，每一次CPU执行到[BX]时，便会自动或者说是默认的从  DS中取值，并且将取得的值作为段地址，因此，当[BX]为0001H时，CPU会从DS中取得一个1000H，由这两个一合成即可以得到正确的物理地址1000H：0000H 。</p>
<p>最后还提醒一点，那就是8086CPU不支持直接将一个数据送入段寄存器中，也就是下面的做法是错误的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV DS,<span class="number">1000</span>H</span><br></pre></td></tr></table></figure>
<h5 id="标志寄存器（FLAG）"><a href="#标志寄存器（FLAG）" class="headerlink" title="标志寄存器（FLAG）:"></a>标志寄存器（FLAG）:</h5><p>前面呢，已经介绍了8086CPU 14个寄存器中的13个了，下面我们将介绍最后一个寄存器也就是FLAG寄存器，FLAG寄存器之所以放到最后一个介绍，是因为其和其他的一些寄存器不同，像AX，BX，CX，DX这些寄存器来说，它们都是用来存放数据的，当然FLAG中存放的也是数据啦，呵呵，不过，AX，BX 这些寄存器中的数据是作为一个整体使用的，最多也就分成一个AL和AH使用而已，但是在FLAG中，数据是按位起作用的，也就是说，FLAG中的每一个位都表示不同的状态，由于一个位也就能表示0和1，自然，FLAG中的每一个位就是用来描述状态的，而且FLAG寄存器中存储的信息通常又被称作程序状态字（PSW）。下面我给出一幅  FLAG  寄存器中各个位的示意图：</p>
<p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012657.png" alt><br>从上面这幅图中可以看出，FLAG的第0个位表示的是CF，第2个位表示的是PF，与此类推 . . . . </p>
<p>首先，我们来看一个列表：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012722.png" alt></p>
<p>上面的这个表怎么看呢？我们通过看下面一幅截图就知道了 。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012745.png" alt></p>
<p>从上面的标记中可以看出，从左到右依次代表OF，DF，SF，ZF，PF，CF标志位的值，再通过与上面的表格相对照可以知道：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OF = <span class="number">0</span> ；</span><br><span class="line">DF = <span class="number">0</span> ；</span><br><span class="line">SF = <span class="number">0</span> ；</span><br><span class="line">ZF = <span class="number">0</span> ；</span><br><span class="line">PF = <span class="number">0</span> ；</span><br><span class="line">CF = <span class="number">0</span> ；</span><br></pre></td></tr></table></figure>
<p>至于为什么我们在Debug模式下，使用R命令时，只会列出这几个标志位，我菜的话是因为相对来说，列出的这几个标志位更为常用，其他的几个标志位并不经常使用的缘故吧 。下面我们就按不同的位来分别介绍这些位所描述的状态，以及它们代表的意义：</p>
<p>CF（Carry  FLag）—-进位标志（第 0 位）：<br>CF:进位标志是用来反映计算时是否产生了由低位向高位的进位，或者产生了从高位到低位的借位 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(运算过程中产生了进位或者借位)</span><br><span class="line">&#123;</span><br><span class="line">    CF  =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    CF  =  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PF（Parity  FLag）—-奇偶标志（第 2 位）：<br>PF:奇偶标志是用来记录相关指令执行后，其结果的所有的  Bit  位中  1  的个数是否为偶数 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(运算结果中 <span class="number">1</span> 的个数为偶数)</span><br><span class="line">&#123;</span><br><span class="line">     PF  =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     PF  =  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AF（Auxiliary  Carry  FLag）—-辅助进位标志（第 4 位）：<br>AF:用来辅助进位标志 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(字节操作中发生低半个字节向高半个字节借位或者进位  ||  字操作中发生低字节向高字节借位或者进位)</span><br><span class="line">&#123;</span><br><span class="line">     AF = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     AF = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ZF（Zero  FLag）–—零标志（第 6 位）：</p>
<p>ZF:记录的是相关的指令执行完毕后，其执行的结果是否为  0 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(执行的结果  ==  <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">     ZF = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     ZF = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SF（Sign  FLag）—-符号标志（第 7 位）：</p>
<p>SF:符号标志，其记录相关指令执行完以后，其结果是否为负数 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(运算结果为负数)</span><br><span class="line">&#123;</span><br><span class="line">      SF  =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">      SF  =  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TF（Trap  FLag）—-追踪标志（第 8 位）：</p>
<p>TF:追踪标志，主要是用于调试时使用 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(TF  ==  <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">     CPU 进入单步方式;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IF（Interrupt-Enable  FLag）—-中断允许标志（第 9 位）：</p>
<p>IF:中断允许标志，其决定  CPU  是否能够响应外部可屏蔽中断请求（以后会做详细介绍） 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(IF  ==  <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">      CPU 能够响应外部的可屏蔽中断请求;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">      CPU 不能够响应外部的可屏蔽中断请求;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DF（Direction  FLag） - 方向标志（第 10 位）：</p>
<p>DF：    方向标志，其用于在串处理指令中，用来控制每次操作后  SI  和  DI  是自增还是自减 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(DF == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">      SI++;</span><br><span class="line">      DI++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">      SI--;</span><br><span class="line">      DI--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OF（OverFlow  FLag）—-溢出标志（第 11 位）：</p>
<p>OF:溢出标志，其通常记录了有符号数运算的结果是否发生了溢出 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(运算发生溢出)</span><br><span class="line">&#123;</span><br><span class="line">      OF  =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">      OF  =  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上面呢，从最简单的开始，循序渐进的介绍了  8086  CPU  中的各个寄存器,同时也通过一些  Demo  来列举了各个寄存器的使用，由于写的比较基础，而且量也比较多，所以，造成博文过长了，读者需一定耐心才能看完，写本篇博文呢，并不是说将来要用汇编去开发个什么东东，实质上，笔者学习汇编的目的也不在此，只是因为先前在接触到底层的寄存器以及内存时，笔者总有一丝不爽的感觉，总是感觉不得要领，所以才会开始汇编的学习，此次推出本系列博文，本意也并不是说要学习汇编做开发，只是为了提升内功而已 。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/11/06/X86%E6%AE%B5%E6%9C%BA%E5%88%B6%E9%A1%B5%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" rel="next" title="X86段机制页机制详解">
                  <i class="fa fa-chevron-left"></i> X86段机制页机制详解
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2019/11/07/gcc%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99/" rel="prev" title="gcc版本下载资源网站">
                  gcc版本下载资源网站 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#开头"><span class="nav-number">1.</span> <span class="nav-text">开头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通用寄存器"><span class="nav-number">2.</span> <span class="nav-text">通用寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据寄存器（AX，BX，CX，DX）："><span class="nav-number">2.1.</span> <span class="nav-text">数据寄存器（AX，BX，CX，DX）：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#AX寄存器"><span class="nav-number">2.1.1.</span> <span class="nav-text">AX寄存器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#BX-寄存器"><span class="nav-number">2.1.2.</span> <span class="nav-text">BX 寄存器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CX-寄存器"><span class="nav-number">2.1.3.</span> <span class="nav-text">CX 寄存器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#DX-寄存器"><span class="nav-number">2.1.4.</span> <span class="nav-text">DX 寄存器</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#指针寄存器（BP，SP）"><span class="nav-number">2.2.</span> <span class="nav-text">指针寄存器（BP，SP）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#BP-寄存器："><span class="nav-number">2.2.1.</span> <span class="nav-text">BP 寄存器：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#变址寄存器（SI，DI）"><span class="nav-number">2.3.</span> <span class="nav-text">变址寄存器（SI，DI）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其他寄存器（CS，IP，SS，SP，DS，ES）"><span class="nav-number">2.4.</span> <span class="nav-text">其他寄存器（CS，IP，SS，SP，DS，ES）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#标志寄存器（FLAG）"><span class="nav-number">2.5.</span> <span class="nav-text">标志寄存器（FLAG）:</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="嘿你的土豆"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">嘿你的土豆</p>
  <div class="site-description" itemprop="description">我的征途是星辰大海</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kkonghao" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;kkonghao" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kkonghao@126.com" title="E-Mail &amp;rarr; mailto:kkonghao@126.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5644679669/profile?topnav=1&wvr=6&is_all=1" title="Weibo &amp;rarr; https:&#x2F;&#x2F;weibo.com&#x2F;5644679669&#x2F;profile?topnav=1&amp;wvr=6&amp;is_all=1" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/yourname" title="Google &amp;rarr; https:&#x2F;&#x2F;plus.google.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i>Google</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">嘿你的土豆</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">54k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">49 分钟</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.4.2
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  






  <script src="/js/local-search.js"></script>













  

  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'NFFFptScgpTiPhpy4cNPz8Ww-gzGzoHsz',
    appKey: '9Az9HaiBHxvseEr35PuO2KaO',
    placeholder: "ヾﾉ≧∀≦)o 来呀！快活呀！~",
    avatar: 'mm',
    meta: guest,
    pageSize: '4' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
