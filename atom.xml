<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>土豆の博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tingyuxuan.com/"/>
  <updated>2019-12-14T14:29:55.000Z</updated>
  <id>http://tingyuxuan.com/</id>
  
  <author>
    <name>嘿你的土豆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内存中页机制</title>
    <link href="http://tingyuxuan.com/2019/12/14/%E5%86%85%E5%AD%98%E4%B8%AD%E9%A1%B5%E6%9C%BA%E5%88%B6/"/>
    <id>http://tingyuxuan.com/2019/12/14/内存中页机制/</id>
    <published>2019-12-14T14:29:55.000Z</published>
    <updated>2019-12-14T14:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="硬件中的分页"><a href="#硬件中的分页" class="headerlink" title="硬件中的分页"></a>硬件中的分页</h4><p>硬件中的分页主要由分页单元（Paging Unit）负责。其作用是把线性地址转换为物理地址。此外还有一个重要的任务就是线性地址的访问权限进行检查，看是否为非法访问。如果非法，则引起一个访问异常。关于分页有以下几个概念需要了解：</p><a id="more"></a><ul><li>页(Page):是指线性地址按固定长度分为若干组，其中每个组就是一个页。简单理解就是程序中所认为的内存空间中的固定大小的一份。</li><li>页帧（Page Frame）：也叫物理页，是物理内存按照固定长度分为若干组，每一个组就是一个页框或物理页。简单理解就是实际的物理内存中的固定大小的一份。</li><li>页表（Page Table）：内核通过建立页表来实现线性地址和物理地址的映射。也就是内核通过页表把页和页帧一一对应。</li></ul><p><font face="楷体">注意:</font></p><ol><li>页帧和页是一一对应的，其大小应该是一样的，有分页单元负责为每一个页指定实际物理内存中的页帧。</li><li>在一个进程中，连续的页不一定会对应着连续的页帧，而是由页表来指定每个页对应的页帧。原因是从进程本身的角度来看，整个内核中就只有它自己，它可以随心所欲的使用全部的内存。但是在真实的系统中，会存在很多个进程，需要这些进程共用物理内存。所以，在进程中的连续页可能是由物理内存中不同地方的页帧组合而来的，其组合方式由页表决定。</li><li>从80386开始，所有的x86架构的处理器都支持分页，主要是由cr0寄存器中的PG标志位控制，该标志位置0时，分页功能就被启用了。</li></ol><h5 id="常规分页"><a href="#常规分页" class="headerlink" title="常规分页"></a>常规分页</h5><p>从80386开始，x86架构处理器一般页的大小为4K。如前所述，32位的线性地址分为三个部分：</p><ul><li>Directory（31~22）：页目录</li><li>Table（21~12）：页表</li><li>Offset（11~0）：页内偏移（这决定了页的大小，因为页内偏移有12位，所以，最大可寻址212=4096=4K大小的内存区域）</li></ul><p>这是最典型的二级分页机制的实现方式，其示意图如下所示：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191227223954.png" alt></p><p>使用多级分页的原因是：为了减少用来存储页表的内存的空间。如果使用单级页表，在4G空间中就需要有220个页表。而每个页表也是会占用内存空间，这么多的页表会浪费很大的内存空间的。</p><p>在最新的linux内核中，采用的是四级分页机制，其原理与二级分页机制一样，只是增加了两级目录，从而可以寻址更大的内存空间。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191227224038.png" alt></p><h5 id="扩展分页"><a href="#扩展分页" class="headerlink" title="扩展分页"></a>扩展分页</h5><p>Linux内核中允许使用扩展分页，所谓扩展分页就是每页的大小不是4K，而是4M。这样做的目的同样也是减少页表的数量。并且可以省去页表，只需要也目录即可了。<br>在扩展分页中，线性地址只有两部分：</p><ul><li>页目录（Directory）[31~22]</li><li>页内偏移（Offset）[21~0]</li></ul><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191227224158.png" alt></p><p>扩展分页可以通过设置cr4寄存器中的PSE标志位与常规分页共存。</p><h5 id="硬件保护方案"><a href="#硬件保护方案" class="headerlink" title="硬件保护方案"></a>硬件保护方案</h5><p>所谓硬件保护就是保护模式的意义所在。就是防止内存的越界访问。<br><strong>具体措施为：</strong><br>在页目录\页表结构中，User\Supervisor标志位为0时，只有CPL=0时，即在内核态时才能对本页寻址。User\Supervisor标志位为1时，无论CPL为何值，可对本页寻址。</p><h5 id="常规分页举例"><a href="#常规分页举例" class="headerlink" title="常规分页举例"></a>常规分页举例</h5><p>因为线性地址中前10位（31~22）是页目录，其可存放为210=1024个页表地址，若进程只用了其中一部分，那么其他剩余部分将别设置为0。同样在页表（21 ~12）也为10位，所以，同样可以存放210=1024个页帧地址，若只用了其中一部分，那么其他剩余部分将别设置为0。这些被设置0的地方，其页目录/页表中的present标志位就是0，而这位为0，就表示该页内存不存在，如果访问，就会产生#14缺页异常</p><h5 id="物理地址的扩展分页机制"><a href="#物理地址的扩展分页机制" class="headerlink" title="物理地址的扩展分页机制"></a>物理地址的扩展分页机制</h5><p>前面所述的分页机制，最大支持4GB的内存寻址，但是在一些大型的服务器等运行场景，需要有更大的内存支持。Intel在32位处理器上解决这个问题，把地址总线从32个管脚扩展到了36个。这样就可以寻址236=64G的内存空间。但是仅仅是硬件上的改变还不足以完成物理地址的扩展，所以在linux中就有了PAE（Physical Address Extension）机制。通过cr4寄存器中的PAE标志位控制PAE机制的开启和关闭。需要注意的是，PAE机制只是扩展了物理内存的容量。而每个进程还是只能访问最大为4GB的内存空间。只是在PAE机制下，可以允许更多的进程共存于系统中。</p><h5 id="64位系统中的分页"><a href="#64位系统中的分页" class="headerlink" title="64位系统中的分页"></a>64位系统中的分页</h5><p>在64位系统中，线性地址有64位，一个标准页为4K，即需要页内偏移需要使用12位，那么还剩下64-12=52位，假使我们仅使用64位中的48位，那么依然还是剩下48-12=36位，如果这36我们平分给页目录和页表，在二级分页模式下，页目录和页表都可以容纳218=25600个项。那么从减少页表数量，节省页表所占内存空间的方面来说，这是不允许的。所以，需要使用更多级的分页机制。<br>linux为了适应不同的架构的分页机制，提供了一种通用的分页机制，可以完美兼容各个架构的分页机制。</p><h5 id="硬件高速缓存（Hardware-cache-memory）"><a href="#硬件高速缓存（Hardware-cache-memory）" class="headerlink" title="硬件高速缓存（Hardware cache memory）"></a>硬件高速缓存（Hardware cache memory）</h5><p>现代处理器的频率已经达到了GHz级别，但是内存却依然在MHz级别。 这就造成了当CPU访问内存时的资源和时间的浪费。并且更加尴尬的是，CPU还需要频繁的访问内存。这就极大地影响到了系统的运行效率。是可忍孰不可忍！于是缓存就应运而生了，由静态存储芯片(SRAM)组成，速度接近处理器的速度，全称就是硬件高速缓存。</p><p>硬件高速缓存位于分页单元和内存之间，由SRAM高速缓存和高速缓存控制器组成。</p><p>高速缓存中分为很多行，每个行对应物理内存中的一个同样大小的区域，每个行里面存放的是最近最常调用的内存区域的内容。高速缓存控制器中存放的是一组表项，其中每个表项对应缓存中的一行。每个表项中有一个标签（tag）和一些状态标志位，这个标签是用来指示当前缓存行对应的内存行。</p><h5 id="转换后援缓冲器"><a href="#转换后援缓冲器" class="headerlink" title="转换后援缓冲器"></a>转换后援缓冲器</h5><p>TLB的作用是加速线性地址到物理地址的转换。当一个线性地址第一次被使用时，是通过内存中存放页表来计算解析出物理地址的。如果使用了TLB，就会把解析出的物理地址放入到一个TLB的表项中。这样以后需要解析该线性地址时，就可以快速的从TLB中得到了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;硬件中的分页&quot;&gt;&lt;a href=&quot;#硬件中的分页&quot; class=&quot;headerlink&quot; title=&quot;硬件中的分页&quot;&gt;&lt;/a&gt;硬件中的分页&lt;/h4&gt;&lt;p&gt;硬件中的分页主要由分页单元（Paging Unit）负责。其作用是把线性地址转换为物理地址。此外还有一个重要的任务就是线性地址的访问权限进行检查，看是否为非法访问。如果非法，则引起一个访问异常。关于分页有以下几个概念需要了解：&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://tingyuxuan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://tingyuxuan.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>段选择子和段描述符之间的关系</title>
    <link href="http://tingyuxuan.com/2019/12/12/%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90%E5%92%8C%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://tingyuxuan.com/2019/12/12/段选择子和段描述符之间的关系/</id>
    <published>2019-12-12T13:56:34.000Z</published>
    <updated>2019-12-12T13:56:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><a id="more"></a><p>段选择子用来表示指向哪一个段描述符，即用来对段描述符进行寻址，由下图可知段选择子的高13位为索引部分，因此也就有能寻到0-(2^13)-1个段描述符，因此段描述符表的大小为8192。段选择子也有特权级的区别分别对应着段选择子的最低2和次最低1位的数据。具体特权级的区别如下所示。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191224214846.png" alt></p><ul><li>INDEX：在GDT数组或LDT数组的索引号</li><li>TI：Table Indicator,这个值为0表示查找GDT，1则查找LDT</li><li>RPL：请求特权级。以什么样的权限去访问段。</li></ul><p>段描述符是用来描述该段的性质的，比如比如段基址和段长之类的性质。我们的寻址过程一般是从段选择子到段描述符，然后从段描述符中取出段基址，加上偏移就形成了我们要访问的地址。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191224214823.png" alt></p><ul><li>BASE: 段基址，由上图中的两部分(BASE 31-24 和 BASE 23-0)组成</li><li>G：LIMIT的单位，该位 0 表示单位是字节，1表示单位是 4KB</li><li>D/B: 该位为 0 表示这是一个 16 位的段，1 表示这是一个 32 位段</li><li>AVL: 该位是用户位，可以被用户自由使用</li><li>LIMIT: 段的界限，单位由 G 位决定。数值上（经过单位换算后的值）等于段的长度（字节）- 1。</li><li>P: 段存在位，该位为 0 表示该段不存在，为 1 表示存在。</li><li>DPL：段权限</li><li>S: 该位为 1 表示这是一个数据段或者代码段。为 0 表示这是一个系统段（比如调用门，中断门等）</li><li>TYPE: 根据 S 位的结果，再次对段类型进行细分。</li></ul><p>8086中，有4个16位的段寄存器：CS、DS、SS、ES，分别用于存放可执行代码的代码段、数据段、堆栈段和其他段的基地址。80386中，有6个16位的段寄存器，但是，这些段寄存器中存放的不再是某个段的基地址，而是某个段的选择符（Selector）。因为16位的寄存器 无法存放32位的段基地址，段基地址只好存放在一个叫做描述符表（Descriptor）的表中。因此，在80386中，我们把段寄存器叫做选择符。下面给出6个段寄存器的名称和用途：</p><p>CS 代码段寄存器<br>DS 数据段寄存器<br>SS 堆栈段寄存器<br>ES、FS及GS 附加数据段寄存器</p><h4 id="段选择子和段描述符表"><a href="#段选择子和段描述符表" class="headerlink" title="段选择子和段描述符表"></a>段选择子和段描述符表</h4><p>在实模式下，16位的段寄存器存储的是真实的段地址；但是在保护模式下，16位的段寄存器就无法放下32位的段地址。因此在保护模式下16位的段寄存器称为段选择子，此时的段寄存器的作用是通过段选择子来选择段描述符表进而确定段地址。段选择子与段描述符表之间的关系如下：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191224215844.png" alt></p><p>首先第1、0位是特权级，表示选择符的特权级，被称为请求者特权级RPL(Requestor Privilege Level)。只有请求者特权级RPL高于(数字低于)或等于相应的描述符特权级DPL，描述符才能被存取，这就可以实现一定程度的保护。第二位为选择域，如果 TI=1，就从局部描述符表中选择相应的描述符，如果TI=0，就从全局描述符表中选择描述符。高13位为索引部分索引能力为8192，用于指向全局或局部描述符表的描述符。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191224234804.png" alt></p><p>我们知道，实模式下是直接在段寄存器中放置段基地址，现在则是通过它来存取相应的描述符来获得段基地址和其它信息，这样以来，存取速度会不会变慢呢？为了解决这个问题，386的每一个段选择符都有一个程序员不可见(也就是说程序员不能直接操纵)的88位（8*8+24）宽的段描述符高速缓冲寄存器与之对应。无论什么时候改变了段寄存器的内容，只要特权级合理，描述符表中的相应的8字节描述符就会自动从描述符表中取出来，装入高速缓冲寄存器中(还有24位其他内容)。一旦装入，以后对那个段的访问就都使用高速缓冲寄存器的描述符信息，而不会再重新从表中去取，这就大大加快了执行的时间。具体的寻址过程如下：</p><p>由于段描述符高速缓冲寄存器的内容只有在重新设置选择符时才被重新装入，所以，当你修改了选择子所选择的描述符后，必须对相应的选择子重新装入，这样，88位描述符高速缓冲寄存器的内容才会发生变化。无论如何，当选择子的值改变时，处理器自动装载不可见部分。</p><p>当不存在分页操作时，保护模式下寻址一个存储器操作如下：</p><ul><li>在段选择子中装入16位数，同时给出32位地址偏移量(比如在ESI、EDI中等等)。</li><li>根据段选择子中的索引值、TI及RPL值，再根据相应描述符表寄存器中的段地址和段界限，进行一系列合法性检查(如特权级检查、界限检查)，该段无问题，就取出相应的描述符放入段描述符高速缓冲寄存器中。</li><li>将描述符中的32位段基地址和放在ESI、EDI等中的32位有效地址相加，就形成了32位物理地址。</li></ul><p>注意：在保护模式下，32位段基地址不必向左移4位，而是直接和偏移量相加形成32位物理地址(只要不溢出)。这样做的好处是：段不必再定位在被16整除的地址上，也不必左移4位再相加。</p><h4 id="如何把段描述符和段选择子填充到段寄存器"><a href="#如何把段描述符和段选择子填充到段寄存器" class="headerlink" title="如何把段描述符和段选择子填充到段寄存器"></a>如何把段描述符和段选择子填充到段寄存器</h4><p>下面来分析一下，如何把 0x1B 、0x23 这两个选择子对应的描述符填充到段寄存器。</p><h5 id="基本数据"><a href="#基本数据" class="headerlink" title="基本数据"></a>基本数据</h5><p>r gdtr查看GDT表的基址，使用dq表示以8字节单元显示内存单元的数据。命令r表示显示寄存器的值，gdtr 也是CPU中的一个寄存器，它保存了GDT的基址。得到基本数据如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|--地址-|--|------------<span class="number">-16</span>进制值-------------|</span><br><span class="line"><span class="number">8003f</span>000   <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00</span>cf9b00`<span class="number">0000f</span>fff</span><br><span class="line"><span class="number">8003f</span>010   <span class="number">00</span>cf9300`<span class="number">0000f</span>fff <span class="number">00</span>cffb00`<span class="number">0000f</span>fff</span><br><span class="line"><span class="number">8003f</span>020   <span class="number">00</span>cff300`<span class="number">0000f</span>fff <span class="number">80008b</span>04`<span class="number">200020</span>ab</span><br><span class="line"><span class="number">8003f</span>030   ffc093df`f0000001 <span class="number">0040f</span>300`<span class="number">00000f</span>ff</span><br></pre></td></tr></table></figure><h5 id="0x1B分析"><a href="#0x1B分析" class="headerlink" title="0x1B分析"></a>0x1B分析</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1B</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1011b</span></span><br><span class="line">索引号：<span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1</span>= <span class="number">3</span> (查找gdt[<span class="number">3</span>])</span><br><span class="line">RPL: <span class="number">11b</span> = <span class="number">3</span></span><br><span class="line">TI: <span class="number">0</span> (查找 GDT 表)</span><br><span class="line">查找到的 GDT 描述符为：gdt[<span class="number">3</span>] = <span class="number">00</span>cffb00`<span class="number">0000f</span>fff</span><br><span class="line">段寄存器结构：</span><br><span class="line">selector  = <span class="number">0x001B</span></span><br><span class="line">attribute = <span class="number">0xcffb</span> (G = <span class="number">1</span> DB = <span class="number">1</span> P = <span class="number">1</span> DPL = <span class="number">3</span> S = <span class="number">1</span> TYPE = <span class="number">1011</span>(非一致代码段，可读已访问过))</span><br><span class="line">base      = <span class="number">0x00000000</span></span><br><span class="line">limit     = <span class="number">0xffffffff</span></span><br></pre></td></tr></table></figure><h5 id="0x23分析"><a href="#0x23分析" class="headerlink" title="0x23分析"></a>0x23分析</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x23</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span> <span class="number">0011b</span></span><br><span class="line">索引号：<span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span> <span class="number">0</span> = <span class="number">4</span></span><br><span class="line">TI: <span class="number">0</span> (查找 GDT 表)</span><br><span class="line">RPL: <span class="number">11b</span> = <span class="number">3</span></span><br><span class="line">查找到的 GDT 描述符为：gdt[<span class="number">4</span>] = <span class="number">00</span>cff300`<span class="number">0000f</span>fff</span><br><span class="line">段寄存器结构：</span><br><span class="line">selector  = <span class="number">0x23</span></span><br><span class="line">attribute = <span class="number">0xcff3</span> (G = <span class="number">1</span> DB = <span class="number">1</span> P = <span class="number">1</span> DPL = <span class="number">3</span> S = <span class="number">1</span> TYPE = <span class="number">0011</span>(可读可写向上扩展的数据段))</span><br><span class="line">base      = <span class="number">0x00000000</span></span><br><span class="line">limit     = <span class="number">0xffffffff</span></span><br></pre></td></tr></table></figure><h4 id="分段机制与分页机制"><a href="#分段机制与分页机制" class="headerlink" title="分段机制与分页机制"></a>分段机制与分页机制</h4><p>分页机制与分段机制是相互独立的。当cr3控制寄存器存储页目录基地址，且cr0控制寄存器的分页标志位（PG位）打开后可以启用分页机制。分页机制只是将分段机制产生的线性地址转化为物理地址。所以，分页机制打开后分段机制依然存在，如果启用保护模式的话，当然有描述符表和选择子。<br><img src="/images/2019/12/24/db223a60-2664-11ea-a084-89920ec74302.png" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h4&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://tingyuxuan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://tingyuxuan.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>线性表的顺序表示和实现</title>
    <link href="http://tingyuxuan.com/2019/11/28/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>http://tingyuxuan.com/2019/11/28/线性表的顺序表示和实现/</id>
    <published>2019-11-28T09:41:33.000Z</published>
    <updated>2019-11-28T09:41:33.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="顺序表的结构定义"><a href="#顺序表的结构定义" class="headerlink" title="顺序表的结构定义"></a>顺序表的结构定义</h4><h5 id="定义代码"><a href="#定义代码" class="headerlink" title="定义代码"></a>定义代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 10 <span class="comment">//线性表存储空间的初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INCREMENT 2  <span class="comment">//线性表存储空间的分配增量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;<span class="comment">//将int类型指定为ElemType类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> *ElemType;</span><br><span class="line">        <span class="keyword">int</span> length;<span class="comment">//当前顺序表的长度</span></span><br><span class="line">        <span class="keyword">int</span> listsize;<span class="comment">//数据表的总长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="顺序表定以后的数据结构"><a href="#顺序表定以后的数据结构" class="headerlink" title="顺序表定以后的数据结构"></a>顺序表定以后的数据结构</h5><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191128182015.png" alt></p><center><font face="楷体">图一：动态分配存储结构</font></center><h4 id="顺序表初始化的基本操作"><a href="#顺序表初始化的基本操作" class="headerlink" title="顺序表初始化的基本操作"></a>顺序表初始化的基本操作</h4><h5 id="顺序表的初始化"><a href="#顺序表的初始化" class="headerlink" title="顺序表的初始化"></a>顺序表的初始化</h5><h6 id="初始化代码"><a href="#初始化代码" class="headerlink" title="初始化代码"></a>初始化代码</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L.elem = (ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * LIST_INIT_SIZE);</span><br><span class="line"><span class="keyword">if</span> (!L.elem)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"malloc error!"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//内存分配失败退出</span></span><br><span class="line">&#125;</span><br><span class="line">L.length = <span class="number">0</span>;<span class="comment">//内存分配成功，则将当前长度初始化为0</span></span><br><span class="line">L.listsize = LIST_INIT_SIZE;<span class="comment">//内存分配成功，将总长度初始化为LIST_INIT_SIZE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="顺序表初始化后的数据结构"><a href="#顺序表初始化后的数据结构" class="headerlink" title="顺序表初始化后的数据结构"></a>顺序表初始化后的数据结构</h6><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191128181809.png" alt></p><center><font face="楷体">图二：初始化后顺序表的表示</font></center><h6 id="顺序表初始化验证"><a href="#顺序表初始化验证" class="headerlink" title="顺序表初始化验证"></a>顺序表初始化验证</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqList L;</span><br><span class="line">InitList(L);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, L.listsize);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顺序表的销毁"><a href="#顺序表的销毁" class="headerlink" title="顺序表的销毁"></a>顺序表的销毁</h4><h5 id="销毁代码"><a href="#销毁代码" class="headerlink" title="销毁代码"></a>销毁代码</h5><p>初始条件：顺序表L已经存在；操作结果：销毁顺序表L；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(L.elem);<span class="comment">//释放指针指向的内存</span></span><br><span class="line">L.elem = <span class="literal">nullptr</span>;<span class="comment">//将指针指向nullptr</span></span><br><span class="line">L.length = <span class="number">0</span>;<span class="comment">//数据指示置成0</span></span><br><span class="line">L.listsize = <span class="number">0</span>;<span class="comment">//长度置0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="销毁后图示"><a href="#销毁后图示" class="headerlink" title="销毁后图示"></a>销毁后图示</h5><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191128184426.png" alt></p><center><font face="楷体">图三：顺序表销毁后的表示</font></center><h4 id="顺序表置空"><a href="#顺序表置空" class="headerlink" title="顺序表置空"></a>顺序表置空</h4><h5 id="置空代码"><a href="#置空代码" class="headerlink" title="置空代码"></a>置空代码</h5><p>初始条件：顺序线性表L已经存在；操作结果：将L置成空表；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="置空后图示"><a href="#置空后图示" class="headerlink" title="置空后图示"></a>置空后图示</h5><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191128184831.png" alt></p><center><font face="楷体">图三：顺序表置空后的表示</font></center><h4 id="顺序表判空"><a href="#顺序表判空" class="headerlink" title="顺序表判空"></a>顺序表判空</h4><h5 id="判空代码"><a href="#判空代码" class="headerlink" title="判空代码"></a>判空代码</h5><p>初始条件：顺序线性表L已经存在；操作结果：若L为空表返回True，反之则返回False；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"yes, is empty"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"no,is not empty"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h6><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191128184831.png" alt></p><center><font face="楷体">图三：顺序表置空后的表示</font></center><h4 id="顺序表长度"><a href="#顺序表长度" class="headerlink" title="顺序表长度"></a>顺序表长度</h4><h5 id="长度代码"><a href="#长度代码" class="headerlink" title="长度代码"></a>长度代码</h5><p>初始条件：顺序线性表L已经存在；操作结果：返回L的长度，注意是实际长度；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="顺序表数据元素查找"><a href="#顺序表数据元素查找" class="headerlink" title="顺序表数据元素查找"></a>顺序表数据元素查找</h4><h5 id="判空代码-1"><a href="#判空代码-1" class="headerlink" title="判空代码"></a>判空代码</h5><p>初始条件：顺序线性表L已经存在；操作结果：返回L的长度，注意是实际长度；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;顺序表的结构定义&quot;&gt;&lt;a href=&quot;#顺序表的结构定义&quot; class=&quot;headerlink&quot; title=&quot;顺序表的结构定义&quot;&gt;&lt;/a&gt;顺序表的结构定义&lt;/h4&gt;&lt;h5 id=&quot;定义代码&quot;&gt;&lt;a href=&quot;#定义代码&quot; class=&quot;headerlink&quot; title=&quot;定义代码&quot;&gt;&lt;/a&gt;定义代码&lt;/h5&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; LIST_INIT_SIZE 10 &lt;span class=&quot;comment&quot;&gt;//线性表存储空间的初始分配量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; LIST_INCREMENT 2  &lt;span class=&quot;comment&quot;&gt;//线性表存储空间的分配增量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ElemType;&lt;span class=&quot;comment&quot;&gt;//将int类型指定为ElemType类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SqList&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *ElemType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length;&lt;span class=&quot;comment&quot;&gt;//当前顺序表的长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; listsize;&lt;span class=&quot;comment&quot;&gt;//数据表的总长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://tingyuxuan.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://tingyuxuan.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>rust语言关于变量问题的一些细节</title>
    <link href="http://tingyuxuan.com/2019/11/23/rust%E8%AF%AD%E8%A8%80%E5%85%B3%E4%BA%8E%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/"/>
    <id>http://tingyuxuan.com/2019/11/23/rust语言关于变量问题的一些细节/</id>
    <published>2019-11-23T10:23:36.000Z</published>
    <updated>2019-11-23T10:23:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><h5 id="不可变绑定"><a href="#不可变绑定" class="headerlink" title="不可变绑定"></a>不可变绑定</h5><h6 id="自动类型推导"><a href="#自动类型推导" class="headerlink" title="自动类型推导"></a>自动类型推导</h6><p>在对变量名进行复制的时候可以不显示的写出变量的类型，Rust语言可以根据数值的类型自动进行变量的类型推导，这类问题比较简单也没有坑可以简单带过。</p><a id="more"></a><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a1 = <span class="number">5</span>; <span class="comment">// 自动推导数据类型i32</span></span><br><span class="line">    <span class="keyword">let</span> a2: <span class="built_in">i32</span> = <span class="number">5</span>; <span class="comment">// 指定数据类型i32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="不可变绑定的重新赋值"><a href="#不可变绑定的重新赋值" class="headerlink" title="不可变绑定的重新赋值"></a>不可变绑定的重新赋值</h6><p>值得注意的是：虽然编译器能够推导出变量的类型，完成对变量的赋值操作。但是不能对该变量进行重新赋值操作。原因是：此时的绑定是不可变绑定，变量声明为不可变类型。<br>具体代码演示如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a1 = <span class="number">5</span>; <span class="comment">// 自动推导数据类型i32</span></span><br><span class="line">    a1 = <span class="number">10</span>; <span class="comment">// error: cannot assign twice to immutable variable `a1`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><font face="楷体">编译器报错为：</font><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0384]: cannot assign twice to immutable variable `a1`</span><br><span class="line">  --&gt; main.rs:<span class="number">14</span>:<span class="number">3</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">11</span> |   <span class="keyword">let</span> a1 = <span class="number">5</span>; <span class="comment">// 自动推导数据类型i32</span></span><br><span class="line">   |       -- first assignment to `a1`</span><br><span class="line">...</span><br><span class="line"><span class="number">14</span> |   a1 = <span class="number">10</span>;</span><br><span class="line">   |   ^^^^^^^ cannot assign twice to immutable variable</span><br></pre></td></tr></table></figure><h5 id="可变绑定"><a href="#可变绑定" class="headerlink" title="可变绑定"></a>可变绑定</h5><h6 id="可变绑定的赋值"><a href="#可变绑定的赋值" class="headerlink" title="可变绑定的赋值"></a>可变绑定的赋值</h6><p>可变绑定即在变量名前面增加一个关键字mut即可。注意有时关键字mut会被编译器提醒warning 提醒coder知道自己使用mut的意图是什么。。对于可变绑定我们首先要了解一下几个问题：一、可变绑定的自动类型推导；二、可变绑定的赋值问题；三、可变绑定的重新绑定问题</p><h6 id="可变绑定自动类型推导"><a href="#可变绑定自动类型推导" class="headerlink" title="可变绑定自动类型推导"></a>可变绑定自动类型推导</h6><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a1=<span class="number">12</span>;<span class="comment">//可变绑定可以实现编译器对绑定数值的自动类型推导，</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="可变绑定的赋值问题"><a href="#可变绑定的赋值问题" class="headerlink" title="可变绑定的赋值问题"></a>可变绑定的赋值问题</h6><p>不可变绑定不能为已经绑定的变量重新绑定数值，可变绑定则可以实现对已绑定变量的重新绑定操作。示例代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在声明变量时，在变量前面加入 mut 关键字，变量就会成为可变绑定的变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a: <span class="built_in">f64</span> = <span class="number">1.0</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改变变量a的值,可变绑定可实现重新赋值</span></span><br><span class="line">    a = <span class="number">2.0</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="可变绑定的重新绑定"><a href="#可变绑定的重新绑定" class="headerlink" title="可变绑定的重新绑定"></a>可变绑定的重新绑定</h6><p>注意可以使用不可变绑已绑定定为可变绑定的未绑定赋值，也可使用可变绑定已绑定为不可变绑定的未绑定赋值。示例代码如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在声明变量时，在变量前面加入 mut 关键字，变量就会成为可变绑定的变量 ok</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a: <span class="built_in">f64</span> = <span class="number">1.0</span>;<span class="comment">//warning: variable does not need to be mutable</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新绑定为不可变</span></span><br><span class="line">    <span class="keyword">let</span> a1 = a;<span class="comment">//可变绑定已绑定为不可变绑定未绑定赋值 ok</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, a1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新绑定为可变</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a2 = a1;<span class="comment">//不可变绑定未绑定为可变绑定已绑定赋值 ok</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><font face="楷体">编译器显示为:</font><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">warning: variable does not need to be mutable</span><br><span class="line"> --&gt; src\main.rs:<span class="number">4</span>:<span class="number">9</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     <span class="keyword">let</span> <span class="keyword">mut</span> a: <span class="built_in">f64</span> = <span class="number">1.0</span>;<span class="comment">//warning: variable does not need to be mutable</span></span><br><span class="line">  |         ----^</span><br><span class="line">  |         |</span><br><span class="line">  |         help: remove this `<span class="keyword">mut</span>`</span><br><span class="line">  |</span><br><span class="line">  = note: `<span class="meta">#[warn(unused_mut)]</span>` on by default</span><br><span class="line"></span><br><span class="line">warning: variable does not need to be mutable</span><br><span class="line">  --&gt; src\main.rs:<span class="number">12</span>:<span class="number">9</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">12</span> |     <span class="keyword">let</span> <span class="keyword">mut</span> a2 = a1;<span class="comment">//</span></span><br><span class="line">   |         ----^^</span><br><span class="line">   |         |</span><br><span class="line">   |         help: remove this `<span class="keyword">mut</span>`</span><br><span class="line"></span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> <span class="number">0.25</span>s</span><br><span class="line">     Running `target\debug\rust_proj.exe`</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure><h5 id="一个经典的错误"><a href="#一个经典的错误" class="headerlink" title="一个经典的错误"></a>一个经典的错误</h5><p>对一个已经发生借用的变量进行操作，会报错<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x: <span class="built_in">u32</span> = <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">let</span> y: &amp;<span class="built_in">u32</span> = &amp;x;<span class="comment">//可变绑定已绑定x为借用赋值</span></span><br><span class="line">    x += <span class="number">1</span>;<span class="comment">//x变量已经被借用，此时对x变量进行内存操作编译器会报错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font face="楷体">编译结果: </font><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">warning: value assigned to `x` is never read</span><br><span class="line"> --&gt; src\main.rs:<span class="number">5</span>:<span class="number">5</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">5</span> |     x += <span class="number">1</span>;<span class="comment">//x变量已经被借用，此时对x变量进行内存操作编译器会报错</span></span><br><span class="line">  |     ^</span><br><span class="line">  |</span><br><span class="line">  = note: `<span class="meta">#[warn(unused_assignments)]</span>` on by default</span><br><span class="line">  = help: maybe it is overwritten before being read?</span><br><span class="line"></span><br><span class="line">error[E0506]: cannot assign to `x` because it is borrowed</span><br><span class="line"> --&gt; src\main.rs:<span class="number">5</span>:<span class="number">5</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |     <span class="keyword">let</span> y: &amp;<span class="built_in">u32</span> = &amp;x;</span><br><span class="line">  |                   -- borrow of `x` occurs here</span><br><span class="line"><span class="number">5</span> |     x += <span class="number">1</span>;<span class="comment">//x变量已经被借用，此时对x变量进行内存操作编译器会报错</span></span><br><span class="line">  |     ^^^^^^ assignment to borrowed `x` occurs here</span><br><span class="line"><span class="number">6</span> |     <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, y);</span><br><span class="line">  |                    - borrow later used here</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0506`.</span><br><span class="line">error: could not compile `rust_proj`.</span><br><span class="line"></span><br><span class="line">To learn more, run the command again with --verbose.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;定义变量&quot;&gt;&lt;a href=&quot;#定义变量&quot; class=&quot;headerlink&quot; title=&quot;定义变量&quot;&gt;&lt;/a&gt;定义变量&lt;/h4&gt;&lt;h5 id=&quot;不可变绑定&quot;&gt;&lt;a href=&quot;#不可变绑定&quot; class=&quot;headerlink&quot; title=&quot;不可变绑定&quot;&gt;&lt;/a&gt;不可变绑定&lt;/h5&gt;&lt;h6 id=&quot;自动类型推导&quot;&gt;&lt;a href=&quot;#自动类型推导&quot; class=&quot;headerlink&quot; title=&quot;自动类型推导&quot;&gt;&lt;/a&gt;自动类型推导&lt;/h6&gt;&lt;p&gt;在对变量名进行复制的时候可以不显示的写出变量的类型，Rust语言可以根据数值的类型自动进行变量的类型推导，这类问题比较简单也没有坑可以简单带过。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Rust" scheme="http://tingyuxuan.com/categories/Rust/"/>
    
    
      <category term="Rust" scheme="http://tingyuxuan.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>C++细节总结</title>
    <link href="http://tingyuxuan.com/2019/11/19/C-%E7%BB%86%E8%8A%82%E6%80%BB%E7%BB%93/"/>
    <id>http://tingyuxuan.com/2019/11/19/C-细节总结/</id>
    <published>2019-11-19T07:05:47.000Z</published>
    <updated>2019-11-19T07:05:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面是对C++语言在使用上的一些细节内容的整理,并对内容进行了相应的整理，如有不足之处欢迎批评指正，内容主要来源于博客:<a href="https://www.cnblogs.com/inception6-lxc/p/8686156.html。" target="_blank" rel="noopener">https://www.cnblogs.com/inception6-lxc/p/8686156.html。</a></p><a id="more"></a><p><strong>1.什么是虚函数？什么是纯虚函数？</strong></p><p>虚函数是允许被其子类重新定义的成员函数。<br>虚函数的声明：virtual returntype func(parameter);目的:引入虚函数的目的是为了动态绑定；<br>纯虚函数声明：virtual returntype func(parameter)=0;目的:引入纯虚函数是为了派生接口。使派生类仅仅只是继承函数的接口。</p><p><strong>2.基类为什么需要虚析构函数？</strong></p><p>大家知道，析构函数是为了在对象不被使用之后释放它的资源，虚函数是为了实现多态。那么把析构函数声明为vitual有什么作用呢？直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;; <span class="comment">//Base的构造函数</span></span><br><span class="line">    ~Base() <span class="comment">//Base的析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class Base!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class Base!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123;&#125;; <span class="comment">//Derived的构造函数</span></span><br><span class="line">    ~Derived() <span class="comment">//Derived的析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class Derived!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class Derived!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived *pTest1 = <span class="keyword">new</span> Derived(); <span class="comment">//Derived类的指针</span></span><br><span class="line">    pTest1-&gt;DoSomething();</span><br><span class="line">    <span class="keyword">delete</span> pTest1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Base *pTest2 = <span class="keyword">new</span> Derived(); <span class="comment">//Base类的指针</span></span><br><span class="line">    pTest2-&gt;DoSomething();</span><br><span class="line">    <span class="keyword">delete</span> pTest2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font face="楷体">程序的输出结果:</font><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191119160948.png" alt></p><font face="楷体">程序的分析:</font><p>可以正常释放pTest1的资源，而没有正常释放pTest2的资源，因为从结果看Derived类的析构函数并没有被调用。通常情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。原因是指针pTest2是Base类型的指针，释放pTest2时只进行Base类的析构函数。在代码~Base析构函数前面加上virtual关键字后的运行结果如下：</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191119161104.png" alt></p><font face="楷体">结论:</font>此时释放指针pTest2时，由于Base的析构函数是virtual的，就会先找到并执行Derived类的析构函数，然后再执行Base类的析构函数，资源正常释放，避免了内存泄漏。因此，只有当一个类被用来作为基类的时候，才会把析构函数写成虚函数。<br>**3.为什么构造函数不是虚函数?**1，从存储空间角度虚函数对应一个vtable，这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。<br>2，从使用角度虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。3、构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。4、从实现上看，vtable在构造函数调用后才建立，因而构造函数不可能成为虚函数 从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数5、当一个构造函数被调用时，它做的首要的事情之一是初始化它的vptr。因此，它只能知道它是“当前”类的，而完全忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码---既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。所以它使用的vptr必须是对于这个类的vtable。而且，只要它是最后的构造函数调用，那么在这个对象的生命期内，vptr将保持被初始化为指向这个vtable, 但如果接着还有一个更晚派生的构造函数被调用，这个构造函数又将设置vptr指向它的vtable，等.直到最后的构造函数结束。vptr的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生 类顺序的另一个理由。但是，当这一系列构造函数调用正发生时，每个构造函数都已经设置vptr指向它自己的vtable。如果函数调用使用虚机制，它将只产生通过它自己的vtable的调用，而不是最后的vtable（所有构造函数被调用后才会有最后的vtable）。**4.当i是一个整数的时候i++和++i那个更快？它们的区别是什么？**几乎一样。i++返回的是i的值，++i返回的是i+1的值，即++i是一个确定的值，是一个可以修改的左值。4.vector的reserve和capacity的区别？reserve()用于让容器预留空间，避免再次分配内存；capacity()返回在重新进行分配以前所能容纳的元素数量。5.如何初始化const和static数据成员？通常在类外申明static成员，但是static const的整型（bool，char，int，long）可以在类中声明且初始化，static const的其他类型必须在类外初始化（包括整型数组）。6.static 和const分别怎么用，类里面static和const可以同时修饰成员函数吗？static的作用：对变量：1.局部变量：在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。- 内存中的位置：静态存储区- 初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）- 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。<br> <font face="楷体">注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。</font><p>2.全局变量<br>在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。</p><ul><li>内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）</li><li>初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）</li><li>作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。</li></ul><p>注：static修饰全局变量，并未改变其存储位置及生命周期，而是改变了其作用域，使当前文件外的源文件无法访问该变量，好处如下：（1）不会被其他文件所访问，修改（2）其他文件中可以使用相同名字的变量，不会发生冲突。对全局函数也是有隐藏作用。而普通全局变量只要定义了，任何地方都能使用，使用前需要声明所有的.c文件，只能定义一次普通全局变量，但是可以声明多次（外部链接）。<br>注意：全局变量的作用域是全局范围，但是在某个文件中使用时，必须先声明。</p><p>  对类中的：<br>  1.成员变量<br>  用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。因此，static成员必须在类外进行初始化(初始化格式： int base::var=10;)，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化 。因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</p><ul><li>不要试图在头文件中定义(初始化)静态数据成员。在大多数的情况下，这样做会引起重复定义这样的错误。即使加上#ifndef #define #endif或者#pragma once也不行。 </li><li>静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以。</li><li><p>静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员的只能声明为 所属类类型的指针或引用。</p><p>2.成员函数</p></li><li>用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。</li><li>静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。base::func(5,3);当static成员函数在类外定义时不需要加static修饰符。</li><li>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。因为静态成员函数不含this指针。 </li><li>不可以同时用const和static修饰成员函数。</li></ul><p>C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。</p><p>我们也可以这样理解：两者的语意是矛盾的。static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。</p><p>const的作用：</p><p>1.限定变量为不可修改。<br>2.限定成员函数不可以修改任何数据成员。<br>3.const与指针：</p><ul><li>const char *p 表示 指向的内容不能改变。</li><li>char * const p，就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。</li></ul><p>7.指针和引用的区别<br>本质上的区别是，指针是一个新的变量，只是这个变量存储的是另一个变量的地址，我们通过访问这个地址来修改变量。<br>而引用只是一个别名，还是变量本身。对引用进行的任何操作就是对变量本身进行操作，因此以达到修改变量的目的。</p><p><font face="楷体"> 注意:</font><br>(1)指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;<span class="keyword">int</span> *p=&amp;a;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;<span class="keyword">int</span> &amp;b=a;</span><br></pre></td></tr></table></figure><p>上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。</p><p>(2)可以有const指针，但是没有const引用（const引用可读不可改，与绑定对象是否为const无关）</p><p>注：引用可以指向常量，也可以指向变量。例如int &amp;a=b，使引用a指向变量b。而为了让引用指向常量，必须使用常量引用，如const int &amp;a=1; 它代表的是引用a指向一个const int型，这个int型的值不能被改变，而不是引用a的指向不能被改变，因为引用的指向本来就是不可变的，无需加const声明。即指针存在常量指针int const *p和指针常量int *const p，而引用只存在常量引用int const &amp;a，不存在引用常量int&amp; const a。</p><p>(3)指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）<br>(4)指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；<br>(5)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。<br>(6)”sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；<br>(7)指针和引用的自增(++)运算意义不一样；<br>(8)指针使用时需要解引用（*），引用则不需要；</p><p>8.什么是多态？多态有什么用途？<br>C++多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的；动态多态是通过虚函数实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定义：“一个接口，多种方法”，程序在运行时才决定要调用的函数。</span><br><span class="line"><span class="number">2.</span>实现：C++多态性主要是通过虚函数实现的，虚函数允许子类重写override(注意和overload的区别，overload是重载，是允许同名函数的表现，这些函数参数列表/类型不同）。</span><br><span class="line"></span><br><span class="line">注：多态与非多态的实质区别就是函数地址是静态绑定还是动态绑定。如果函数的调用在编译器编译期间就可以确定函数的调用地址，并产生代码，说明地址是静态绑定的；如果函数调用的地址是 需要在运行期间才确定，属于动态绑定。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>目的：接口重用。封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。</span><br><span class="line"><span class="number">4.</span>用法：声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。</span><br><span class="line">用一句话概括：在基类的函数前加上<span class="keyword">virtual</span>关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</span><br></pre></td></tr></table></figure><p>9.关于重载、重写、隐藏的区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Overload(重载)：在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。</span><br><span class="line">（<span class="number">1</span>）相同的范围（在同一个类中）；</span><br><span class="line">（<span class="number">2</span>）函数名字相同；</span><br><span class="line">（<span class="number">3</span>）参数不同；</span><br><span class="line">（<span class="number">4</span>）<span class="keyword">virtual</span> 关键字可有可无。</span><br><span class="line"></span><br><span class="line">Override(覆盖或重写)：是指派生类函数覆盖基类函数，特征是：</span><br><span class="line">（<span class="number">1</span>）不同的范围（分别位于派生类与基类）；</span><br><span class="line">（<span class="number">2</span>）函数名字相同；</span><br><span class="line">（<span class="number">3</span>）参数相同；</span><br><span class="line">（<span class="number">4</span>）基类函数必须有<span class="keyword">virtual</span> 关键字。</span><br><span class="line">注：重写基类虚函数的时候，会自动转换这个函数为<span class="keyword">virtual</span>函数，不管有没有加<span class="keyword">virtual</span>，因此重写的时候不加<span class="keyword">virtual</span>也是可以的，不过为了易读性，还是加上比较好。</span><br><span class="line"></span><br><span class="line">Overwrite(重写)：隐藏，是指派生类的函数屏蔽了与其同名的基类函数，规则如下：</span><br><span class="line">（<span class="number">1</span>）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无<span class="keyword">virtual</span>关键字，基类的函数将被隐藏（注意别与重载混淆）。</span><br><span class="line">（<span class="number">2</span>）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有<span class="keyword">virtual</span>关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</span><br></pre></td></tr></table></figure><p>10.虚函数表<br>详细解释可以参考博客：<a href="https://www.cnblogs.com/jin521/p/5602190.html" target="_blank" rel="noopener">https://www.cnblogs.com/jin521/p/5602190.html</a></p><p>多态是由虚函数实现的，而虚函数主要是通过虚函数表（V-Table）来实现的。</p><p>如果一个类中包含虚函数（virtual修饰的函数），那么这个类就会包含一张虚函数表，虚函数表存储的每一项是一个虚函数的地址。如下图：</p><p><img src="/images/2019/11/19/5f0f2c60-0a9b-11ea-86c0-1995a9c73c6e.png" alt="image.png"></p><p>这个类的每一个对象都会包含一个虚指针（虚指针存在于对象实例地址的最前面，保证虚函数表有最高的性能），这个虚指针指向虚函数表。</p><p>注：对象不包含虚函数表，只有虚指针，类才包含虚函数表，派生类会生成一个兼容基类的虚函数表。</p><ul><li><p>原始基类的虚函数表<br>下图是原始基类的对象，可以看到虚指针在地址的最前面，指向基类的虚函数表（假设基类定义了3个虚函数）<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191119150913.png" alt></p></li><li><p>单继承时的虚函数（无重写基类虚函数）<br>假设现在派生类继承基类，并且重新定义了3个虚函数，派生类会自己产生一个兼容基类虚函数表的属于自己的虚函数表。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191119151003.png" alt><br>Derive Class继承了Base Class中的3个虚函数，准确说是该函数的实体地址被拷贝到Derive Class的虚函数列表中，派生新增的虚函数置于虚函数列表后面，并按声明顺序摆放。</p></li><li>单继承时的虚函数（重写基类虚函数）<br>现在派生类重写基类的x函数，可以看到这个派生类构建自己的虚函数表的时候，修改了base::x()这一项，指向了自己的虚函数。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191119151052.png" alt></li><li>多重继承时的虚函数（class Derived :public Base1,public Base2）<br>这个派生类多重继承了两个基类base1，base2，因此它有两个虚函数表。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191119151132.png" alt><br>它的对象会有多个虚指针（据说和编译器相关），指向不同的虚函数表。<br>注：有关以上虚函数表等详见c++对象模型。链接地址：<a href="https://www.cnblogs.com/inception6-lxc/p/9273918.html" target="_blank" rel="noopener">https://www.cnblogs.com/inception6-lxc/p/9273918.html</a></li></ul><p>纯虚函数：<br>　　定义：在很多情况下，基类本身生成对象是不合情理的。为了解决这个问题，方便使用类的多态性，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;）纯虚函数不能再在基类中实现，编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。称带有纯虚函数的类为抽象类。<br>　　特点：<br>　　1，当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；（避免类被实例化且在编译时候被发现，可以采用此方法）<br>　　2，这个方法必须在派生类(derived class)中被实现；<br>　　目的：使派生类仅仅只是继承函数的接口。</p><p>9.vector中size()和capacity()的区别。<br>size()指容器当前拥有的元素个数（对应的resize(size_type)会在容器尾添加或删除一些元素，来调整容器中实际的内容，使容器达到指定的大小。）；capacity（）指容器在必须分配存储空间之前可以存储的元素总数。</p><p>size表示的这个vector里容纳了多少个元素，capacity表示vector能够容纳多少元素，它们的不同是在于vector的size是2倍增长的。如果vector的大小不够了，比如现在的capacity是4，插入到第五个元素的时候，发现不够了，此时会给他重新分配8个空间，把原来的数据及新的数据复制到这个新分配的空间里。（会有迭代器失效的问题）</p><p>10.new和malloc的区别。<br>       详细参考：链接</p><p>new是运算符，malloc()是一个库函数；<br>new会调用构造函数，malloc不会；<br>new返回指定类型指针，malloc返回void*指针，需要强制类型转换；<br>new会自动计算需分配的空间，malloc不行；<br>new可以被重载，malloc不能。</p><p>11.C++的内存分区<br>栈区（stack）：主要存放函数参数以及局部变量，由系统自动分配释放。<br>堆区（heap）：由用户通过 malloc/new 手动申请，手动释放。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>全局/静态区：存放全局变量、静态变量；程序结束后由系统释放。<br>字符串常量区：字符串常量就放在这里，程序结束后由系统释放。<br>代码区：存放程序的二进制代码。</p><p>12.vector、map、multimap、unordered_map、unordered_multimap的底层数据结构，以及几种map容器如何选择？<br>底层数据结构：<br>vector基于数组，<br>map、multimap基于红黑树，<br>unordered_map、unordered_multimap基于哈希表。</p><p>根据应用场景进行选择：<br>map/unordered_map 不允许重复元素<br>multimap/unordered_multimap 允许重复元素<br>map/multimap 底层基于红黑树，元素自动有序，且插入、删除效率高<br>unordered_map/unordered_multimap 底层基于哈希表，故元素无序，查找效率高。</p><p>13.内存泄漏怎么产生的？如何避免？<br>内存泄漏一般是指堆内存的泄漏，也就是程序在运行过程中动态申请的内存空间不再使用后没有及时释放，导致那块内存不能被再次使用。<br>更广义的内存泄漏还包括未对系统资源的及时释放，比如句柄、socket等没有使用相应的函数释放掉，导致系统资源的浪费。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRTDBG_MAP_ALLOC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;crtdbg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//在入口函数中包含 _CrtDumpMemoryLeaks();</span></span><br><span class="line"><span class="comment">//即可检测到内存泄露</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以如下测试函数为例：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *pChars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//delete[]pChars;</span></span><br><span class="line">_CrtDumpMemoryLeaks();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解决方法：</p><ul><li>养成良好的编码习惯和规范，记得及时释放掉内存或系统资源。</li><li>重载new和delete，以链表的形式自动管理分配的内存。</li><li>使用智能指针，share_ptr、auto_ptr、weak_ptr。</li></ul><p>14.说几个C++11的新特性</p><ul><li>auto类型推导</li><li>范围for循环</li><li>lambda函数</li><li>override 和 final 关键字</li></ul><p>如果不使用override，当你手一抖，将foo()写成了f00()会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125; <span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;     <span class="comment">//OK</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">foo</span><span class="params">()</span></span>;       <span class="comment">// OK</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> override</span>; <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f00</span><span class="params">()</span></span>;      <span class="comment">//OK</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f0o</span><span class="params">()</span> override</span>; <span class="comment">//Error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> final</span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> final</span>; <span class="comment">// Error: 父类中没有 bar虚函数可以被重写或final</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">final</span> :</span> A <span class="comment">// 指明B是不可以被继承的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> override</span>; <span class="comment">// Error: 在A中已经被final了</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> B <span class="comment">// Error: B is final</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>空指针常量nullptr</li><li>线程支持、智能指针等</li></ul><p>15.C和C++区别？<br>C++在C的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。</p><p>16.const与#define的区别<br>1.编译器处理方式<br>define – 在预处理阶段进行替换<br>const – 在编译时确定其值</p><p>2.类型检查<br>define – 无类型，不进行类型安全检查，可能会产生意想不到的错误<br>const – 有数据类型，编译时会进行类型检查</p><p>3.内存空间<br>define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大<br>const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝</p><p>4.其他<br>在编译时， 编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。<br>宏替换只作替换，不做计算，不做表达式求解。</p><p>17.悬空指针与野指针区别</p><ul><li>悬空指针：当所指向的对象被释放或者收回，但是没有让指针指向NULL；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">char</span> *dp = <span class="literal">NULL</span>;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">char</span> c;</span><br><span class="line">       dp = &amp;c;</span><br><span class="line">   &#125; </span><br><span class="line">  <span class="comment">//变量c释放，dp变成空悬指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *dp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(A_CONST);</span><br><span class="line">    <span class="built_in">free</span>(dp);         <span class="comment">//dp变成一个空悬指针</span></span><br><span class="line">    dp = <span class="literal">NULL</span>;        <span class="comment">//dp不再是空悬指针</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>野指针：那些未初始化的指针；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *dp;<span class="comment">//野指针，没有初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *sdp;<span class="comment">//非野指针，因为静态变量会默认初始化为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>18.struct与class的区别？<br>本质区别是访问的默认控制：默认的继承访问权限，class是private，struct是public；</p><p>19.sizeof和strlen的区别？<br>功能不同：<br>sizeof是操作符，参数为任意类型，主要计算类型占用内存大小。<br>strlen（）是函数，其函数原型为：extern unsigned int strlen(char <em>s）;其参数为char</em>,strlen只能计算以”\0”结尾字符串的长度，计算结果不包括”\0”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ss = <span class="string">"0123456789"</span>;</span><br><span class="line"><span class="comment">//s1=4,ss为字符指针在内存中占用4个字节</span></span><br><span class="line"><span class="keyword">int</span> s1 = <span class="keyword">sizeof</span>(ss);</span><br><span class="line"><span class="comment">//s2=10,计算字符串ss的长度</span></span><br><span class="line"><span class="keyword">int</span> s2 = <span class="built_in">strlen</span>(ss);</span><br></pre></td></tr></table></figure><p>参数不同：<br>当将字符数组作为sizeof（）的参数时，计算字符数组占用内存大小；当将字符数组作为strlen（)函数，字符数组转化为char<em>。因为sizeof的参数为任意类型，而strlen（）函数参数只能为char</em>，当参数不是char<em>必须转换为char</em>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abced"</span>;</span><br><span class="line"><span class="comment">//a为6（1*6），字符数组str包含6个元素（a,b,c,d,e,\0)，每个元素占用1个字节</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">sizeof</span>(str);</span><br><span class="line"><span class="comment">//len为5，不包含"\0"，</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="comment">//str[0]是字符元素a，所以b=1</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="keyword">sizeof</span>(str[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p><p>21.virtual, inline, decltype,volatile,static, const关键字的作用？使用场景？<br>inline：在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//函数定义为inline即:内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> *<span class="title">dbtest</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (i % <span class="number">2</span> &gt; <span class="number">0</span>) ? <span class="string">"奇"</span> : <span class="string">"偶"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i:%d    奇偶性:%s /n"</span>, i, dbtest(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//在for循环的每个dbtest(i)的地方替换成了 (i % 2 &gt; 0) ? "奇" : "偶"，避免了频繁调用函数，对栈内存的消耗</span></span><br></pre></td></tr></table></figure><p>decltype:从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。还有可能是函数的返回类型为某表达式的的值类型。</p><p>volatile：volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p><p>static:<br>隐藏在变量和函数名前面如果未加static，则它们是全局可见的。加了static，就会对其它源文件隐藏，利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲  突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏 。</p><p>2.static变量中的记忆功能和全局生存期<br>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">＃include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>; <span class="comment">//在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a</span></span><br><span class="line"><span class="keyword">return</span> count--;   <span class="comment">//就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量：</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"global\t\tlocal static\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (; count &lt;= <span class="number">10</span>; ++count)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t\t%d\n"</span>, count, fun());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。</p><p> 3.static的第三个作用是默认初始化为0（static变量）</p><p>最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。</p><p> 4.static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠）</p><p> 在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：</p><p>(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。<br>(2)不能将静态成员函数定义为虚函数。<br>(3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。<br>(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）<br>(5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。<br>(6)静态数据成员在&lt;定义或说明&gt;时前面加关键字static。<br>(7)静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）<br>(8)静态成员初始化与一般数据成员初始化不同:</p><p>初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；<br>初始化时不加该成员的访问权限控制符private，public等；<br>初始化时使用作用域运算符来标明它所属类；<br>静态数据成员初始化的格式：&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</p><p>(9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p><p>22.深拷贝与浅拷贝的区别？<br>1.什么时候用到拷贝函数？<br>  a.一个对象以值传递的方式传入函数体；<br>  b.一个对象以值传递的方式从函数返回；<br>  c.一个对象需要通过另外一个对象进行初始化。<br>  如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会自动生成一个默认的拷贝构造函数，该构造函数完成对象之间的位拷贝。位拷贝又称浅拷贝；</p><p>2.是否应该自定义拷贝函数？<br> 自定义拷贝构造函数是一种良好的编程风格，它可以阻止编译器形成默认的拷贝构造函数，提高源码效率。</p><p>3.什么叫深拷贝？什么是浅拷贝？两者异同？<br>  如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。</p><p>4.深拷贝好还是浅拷贝好？<br>如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。</p><p>参考博客：<br>    <a href="https://blog.csdn.net/caoshangpa/article/details/79226270" target="_blank" rel="noopener">https://blog.csdn.net/caoshangpa/article/details/79226270</a><br>        <a href="http://www.cnblogs.com/BlueTzar/articles/1223313.html" target="_blank" rel="noopener">http://www.cnblogs.com/BlueTzar/articles/1223313.html</a></p><p>23.派生类中构造函数，析构函数调用顺序？<br>构造函数：“先基后派”；析构函数：“先派后基”。</p><p>24.C++类中数据成员初始化顺序？</p><p>1.成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。<br>2.如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。<br>3.类中const成员常量必须在构造函数初始化列表中初始化。<br>4.类中static成员变量，只能在类内外初始化(同一类的所有实例共享静态成员变量)。</p><p>初始化顺序：</p><ol><li>基类的静态变量或全局变量</li><li>派生类的静态变量或全局变量</li><li>基类的成员变量</li><li>派生类的成员变量</li></ol><p>25.结构体内存对齐问题？结构体/类大小的计算？<br>注：内存对齐是看类型，而不是看总的字节数。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignData1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">7</span>]; <span class="comment">//a后面并不会补上3个字节，而是由于char的类型所以不用补。</span></span><br><span class="line"><span class="keyword">short</span> c;</span><br><span class="line"><span class="keyword">char</span> d;</span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignData2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">bool</span> a;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">2</span>]; <span class="comment">//a后面并不会补上7个字节，而是根据int的类型补3个字节。</span></span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">&#125; Node2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Node) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//16</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Node2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//20</span></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接:<br><a href="https://www.cnblogs.com/E-star/archive/2013/04/09/3009375.html" target="_blank" rel="noopener">https://www.cnblogs.com/E-star/archive/2013/04/09/3009375.html</a><br>补充：</p><ul><li>每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍。为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节。</li><li>最终占用字节数为成员类型中最大占用字节数的整数倍。</li><li>一般的结构体成员按照默认对齐字节数递增或是递减的顺序排放，会使总的填充字节数最少。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignData1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">short</span> b;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> d;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个结构体在编译以后，为了字节对齐，会被整理成这个样子：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlignData1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">char</span> padding[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">short</span> b;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> d;</span><br><span class="line"><span class="keyword">char</span> padding[<span class="number">3</span>];</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>含有虚函数的类的大小链接地址:<br><a href="https://www.cnblogs.com/younes/archive/2010/06/07/1753488.html" target="_blank" rel="noopener">https://www.cnblogs.com/younes/archive/2010/06/07/1753488.html</a></p><p>补充：联合体的大小计算：<br>联合体所占的空间不仅取决于最宽成员，还跟所有成员有关系，即其大小必须满足两个条件：1)大小足够容纳最宽的成员；2)大小能被其包含的所有基本数据类型的大小所整除。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> U1  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">11</span>];  </span><br><span class="line">    <span class="keyword">double</span> d;  </span><br><span class="line">&#125;;  <span class="comment">//16，char s[11]按照char=1可以整除</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">union</span> U2  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">5</span>];  </span><br><span class="line">    <span class="keyword">double</span> d;  </span><br><span class="line">&#125;;  <span class="comment">//8</span></span><br></pre></td></tr></table></figure><br>26.static_cast, dynamic_cast, const_cast, reinpreter_cast的区别？<br>链接地址:<br><a href="https://www.cnblogs.com/chio/archive/2007/07/18/822389.html" target="_blank" rel="noopener">https://www.cnblogs.com/chio/archive/2007/07/18/822389.html</a></p><p>补充：static_cast与dynamic_cast<br>cast发生的时间不同，一个是static编译时，一个是runtime运行时；<br>static_cast是相当于C的强制类型转换，用起来可能有一点危险，不提供运行时的检查来确保转换的安全性。<br>dynamic_cast用于转换指针和和引用，不能用来转换对象 ——主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。在多态类型之间的转换主要使用dynamic_cast，因为类型提供了运行时信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBasic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span> :</span> <span class="keyword">public</span> CBasic</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CBasic cBasic;</span><br><span class="line">CDerived cDerived;</span><br><span class="line">CBasic *pB1 = <span class="keyword">new</span> CBasic;</span><br><span class="line">CBasic *pB2 = <span class="keyword">new</span> CDerived;</span><br><span class="line">CBasic *pB3 = <span class="keyword">new</span> CBasic;</span><br><span class="line">CBasic *pB4 = <span class="keyword">new</span> CDerived;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dynamic cast failed, so pD1 is null.</span></span><br><span class="line">CDerived *pD1 = <span class="keyword">dynamic_cast</span>&lt;CDerived *&gt;(pB1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//dynamic cast succeeded, so pD2 points to  CDerived object</span></span><br><span class="line">CDerived *pD2 = <span class="keyword">dynamic_cast</span>&lt;CDerived *&gt;(pB2);</span><br><span class="line"><span class="comment">//pD3将是一个指向该CBasic类型对象的指针，对它进行CDerive类型的操作将是不安全的</span></span><br><span class="line">CDerived *pD3 = <span class="keyword">static_cast</span>&lt;CDerived *&gt;(pB3);</span><br><span class="line"><span class="comment">//static_cast成功</span></span><br><span class="line">CDerived *pD4 = <span class="keyword">static_cast</span>&lt;CDerived *&gt;(pB4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//dynamci cast failed, so throw an exception.</span></span><br><span class="line"><span class="comment">//    CDerived &amp; rD1 = dynamic_cast&lt;CDerived &amp;&gt; (*pB1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dynamic cast succeeded, so rD2 references to CDerived object.</span></span><br><span class="line">CDerived &amp;rD2 = <span class="keyword">dynamic_cast</span>&lt;CDerived &amp;&gt;(*pB2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：CBasic要有虚函数，否则会编译出错；static_cast则没有这个限制。</p><p>27.智能指针</p><ul><li>智能指针是在 <memory> 头文件中的std命名空间中定义的，该指针用于确保程序不存在内存和资源泄漏且是异常安全的。它们对RAII“获取资源即初始化”编程至关重要，RAII的主要原则是为将任何堆分配资源（如动态分配内存或系统对象句柄）的所有权提供给其析构函数包含用于删除或释放资源的代码以及任何相关清理代码的堆栈分配对象。大多数情况下，当初始化原始指针或资源句柄以指向实际资源时，会立即将指针传递给智能指针。</memory></li><li>智能指针的设计思想：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。</li><li>unique_ptr只允许基础指针的一个所有者。unique_ptr小巧高效；大小等同于一个指针且支持右值引用，从而可实现快速插入和对STL集合的检索。</li><li>shared_ptr采用引用计数的智能指针，主要用于要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时）的情况。当所有的shared_ptr所有者超出了范围或放弃所有权，才会删除原始指针。大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块。最安全的分配和使用动态内存的方法是调用make_shared标准库函数，此函数在动态分配内存中分配一个对象并初始化它，返回对象的shared_ptr。</li></ul><p>补充:<br>链接地址:<a href="https://www.cnblogs.com/lanxuezaipiao/p/4132096.html" target="_blank" rel="noopener">https://www.cnblogs.com/lanxuezaipiao/p/4132096.html</a></p><p>28.计算类大小例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;: <span class="keyword">sizeof</span>(A) = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125; &#125;;: <span class="keyword">sizeof</span>(A) = <span class="number">4</span>(<span class="number">32</span>位机器)/<span class="number">8</span>(<span class="number">64</span>位机器);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> a; &#125;;: <span class="keyword">sizeof</span>(A) = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">int</span> a; &#125;;: <span class="keyword">sizeof</span>(A) = <span class="number">4</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> a; <span class="keyword">int</span> b; &#125;;: <span class="keyword">sizeof</span>(A) = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><br>类中用static声明的成员变量不计算入类的大小中，因为static data不是实例的一部分。static的属于全局的，他不会占用类的存储，他有专门的地方存储 （全局变量区）</p><p>29.大端与小端的概念？各自的优势是什么？<br>大端与小端是用来描述多字节数据在内存中的存放顺序，即字节序。大端（Big Endian）指低地址端存放高位字节，小端（Little Endian）是指低地址端存放低位字节。<br>需要记住计算机是以字节为存储单位。<br>为了方便记忆可把大端和小端称作高尾端和低尾端，eg：如果是高尾端模式一个字符串“11223344”把尾部“44”放在地址的高位，如果是地尾端模式，把“44”放在地址的低位。</p><p>各自优势：</p><p>Big Endian：符号位的判定固定为第一个字节，容易判断正负。<br>Little Endian：长度为1，2，4字节的数，排列方式都是一样的，数据类型转换非常方便。<br>举一个例子，比如数字0x12 34 56 78在内存中的表示形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)大端模式：</span><br><span class="line">低地址 -----------------&gt; 高地址</span><br><span class="line"><span class="number">0x12</span> | <span class="number">0x34</span> | <span class="number">0x56</span> | <span class="number">0x78</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)小端模式：</span><br><span class="line">低地址 ------------------&gt; 高地址</span><br><span class="line"><span class="number">0x78</span> | <span class="number">0x56</span> | <span class="number">0x34</span> | <span class="number">0x12</span></span><br></pre></td></tr></table></figure><p>31.C++vector与list区别<br>链接地址:<br><a href="https://www.cnblogs.com/shijingjing07/p/5587719.html" target="_blank" rel="noopener">https://www.cnblogs.com/shijingjing07/p/5587719.html</a></p><p>32.C语言中static关键字作用<br>在C语言中static的作用如下</p><p>第一、在修饰变量的时候，static修饰的静态局部变量只执行一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。<br>第二、static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。<br>第三、static修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。Static修饰的局部变量存放在全局数据区的静态变量区。初始化的时候自动初始化为0；<br>（1）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用static修饰<br>（2）考虑到数据安全性（当程想要使用全局变量的时候应该先考虑使用static）</p><p>在C++中static关键字除了具有C中的作用还有在类中的使用<br>在类中，static可以用来修饰静态数据成员和静态成员方法<br>静态数据成员<br>（1）静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变。<br>（2）静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间。<br>（3）静态数据成员可以被初始化，但是只能在类体外进行初始化，若为对静态数据成员赋初值，则编译器会自动为其初始化为0<br>（4）静态数据成员既可以通过对象名引用，也可以通过类名引用。</p><p>静态成员函数<br>（1）静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员。<br>（2）非静态成员函数有this指针，而静态成员函数没有this指针。<br>（3）静态成员函数主要用来访问静态数据成员而不能访问非静态成员。</p><p>33.C/C++中堆和栈的区别<br>讲解全面的一篇博客：<a href="https://blog.csdn.net/u013238950/article/details/49368925" target="_blank" rel="noopener">https://blog.csdn.net/u013238950/article/details/49368925</a><br>                  <a href="https://www.cnblogs.com/chanchan/p/7820508.html" target="_blank" rel="noopener">https://www.cnblogs.com/chanchan/p/7820508.html</a></p><p>34.定义一个空类编译器做了哪些操作？<br>如果你只是声明一个空类，不做任何事情的话，编译器会自动为你生成一个默认构造函数、一个拷贝默认构造函数、一个默认拷贝赋值操作符和一个默认析构函数。这些函数只有在第一次被调用时，才会被编译器创建。所有这些函数都是inline和public的。</p><p>定义一个空类例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>一个空的class在C++编译器处理过后就不再为空，编译器会自动地为我们声明一些member function，一般编译过就相当于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Empty();<span class="comment">// 缺省构造函数//</span></span><br><span class="line">Empty(<span class="keyword">const</span> Empty &amp;); <span class="comment">// 拷贝构造函数//</span></span><br><span class="line">~Empty();<span class="comment">// 析构函数//</span></span><br><span class="line">Empty &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Empty &amp;);         <span class="comment">// 赋值运算符//</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>需要注意的是，只有当你需要用到这些函数的时候，编译器才会去定义它们。</p><p>35.友元函数和友元类<br>链接地址:<a href="https://www.cnblogs.com/staring-hxs/p/3432161.html" target="_blank" rel="noopener">https://www.cnblogs.com/staring-hxs/p/3432161.html</a></p><p>36.什么情况下，类的析构函数应该声明为虚函数？为什么？<br>基类指针可以指向派生类的对象（多态性），如果删除该指针delete []p；就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。<br>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。</p><p>37.哪些函数不能成为虚函数？<br>不能被继承的函数和不能被重写的函数。</p><p>1）普通函数<br>普通函数不属于成员函数，是不能被继承的。普通函数只能被重载，不能被重写，因此声明为虚函数没有意义。因为编译器会在编译时绑定函数。<br>而多态体现在运行时绑定。通常通过基类指针指向子类对象实现多态。</p><p>2）友元函数<br>友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</p><p>3）构造函数<br>首先说下什么是构造函数，构造函数是用来初始化对象的。假如子类可以继承基类构造函数，那么子类对象的构造将使用基类的构造函数，而基类构造函数并不知道子类的有什么成员，显然是不符合语义的。从另外一个角度来讲，多态是通过基类指针指向子类对象来实现多态的，在对象构造之前并没有对象产生，因此无法使用多态特性，这是矛盾的。因此构造函数不允许继承。</p><p>4）内联成员函数<br>我们需要知道内联函数就是为了在代码中直接展开，减少函数调用花费的代价。也就是说内联函数是在编译时展开的。而虚函数是为了实现多态，是在运行时绑定的。因此显然内联函数和多态的特性相违背。</p><p>5）静态成员函数<br>首先静态成员函数理论是可继承的。但是静态成员函数是编译时确定的，无法动态绑定，不支持多态，因此不能被重写，也就不能被声明为虚函数。、</p><p>38.编写一个有构造函数，析构函数，赋值函数，和拷贝构造函数的String类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">String(<span class="keyword">const</span> <span class="keyword">char</span> *str);</span><br><span class="line">String(<span class="keyword">const</span> String &amp;other);</span><br><span class="line">~String();</span><br><span class="line">String &amp;operate = (<span class="keyword">const</span> String &amp;other);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">*m_data = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> length = <span class="built_in">strlen</span>(str);</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::String(<span class="keyword">const</span> String &amp;other)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> length = <span class="built_in">strlen</span>(other.m_data);</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::~String()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::String &amp;operate = (<span class="keyword">const</span> String &amp;other)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (&amp;other == *<span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//检查自赋值</span></span><br><span class="line"><span class="keyword">delete</span>[] m_data;  <span class="comment">//释放原有的内存资源</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="built_in">strlen</span>(other.m_data);</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回本对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>39.this指针的理解<br>链接地址:<a href="https://www.cnblogs.com/liushui-sky/p/5802981.html" target="_blank" rel="noopener">https://www.cnblogs.com/liushui-sky/p/5802981.html</a></p><p>40.程序加载时的内存分布</p><ul><li><p>在多任务操作系统中，每个进程都运行在一个属于自己的虚拟内存中，而虚拟内存被分为许多页，并映射到物理内存中，被加载到物理内存中的文件才能够被执行。这里我们主要关注程序被装载后的内存布局，其可执行文件包含了代码段，数据段，BSS段，堆，栈等部分，其分布如下图所示。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191119153721.png" alt></p></li><li><p>代码段(.text)：用来存放可执行文件的机器指令。存放在只读区域，以防止被修改。</p></li><li>只读数据段(.rodata)：用来存放常量存放在只读区域，如字符串常量、全局const变量等。</li><li>可读写数据段(.data)：用来存放可执行文件中已初始化全局变量，即静态分配的变量和全局变量。</li><li>BSS段(.bss)：未初始化的全局变量和局部静态变量以及初始化为0的全局变量一般放在.bss的段里，以节省内存空间。eg:static int a=0;(初始化为0的全局变量（静态变量）放在.bss)。</li><li>堆：用来容纳应用程序动态分配的内存区域。当程序使用malloc或new分配内存时，得到的内存来自堆。堆通常位于栈的下方。</li><li>栈：用于维护函数调用的上下文。栈通常分配在用户空间的最高地址处分配。</li><li>动态链接库映射区：如果程序调用了动态链接库，则会有这一部分。该区域是用于映射装载的动态链接库。</li><li>保留区：内存中受到保护而禁止访问的内存区域。</li></ul><p>41.智能指针</p><ul><li>智能指针是在 <memory> 头文件中的std命名空间中定义的，该指针用于确保程序不存在内存和资源泄漏且是异常安全的。它们对RAII“获取资源即初始化”编程至关重要，RAII的主要原则是为将任何堆分配资源（如动态分配内存或系统对象句柄）的所有权提供给其析构函数包含用于删除或释放资源的代码以及任何相关清理代码的堆栈分配对象。大多数情况下，当初始化原始指针或资源句柄以指向实际资源时，会立即将指针传递给智能指针。</memory></li><li>智能指针的设计思想：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。</li><li>unique_ptr只允许基础指针的一个所有者。unique_ptr小巧高效；大小等同于一个指针且支持右值引用，从而可实现快速插入和对STL集合的检索。</li><li>shared_ptr采用引用计数的智能指针，主要用于要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时）的情况。当所有的shared_ptr所有者超出了范围或放弃所有权，才会删除原始指针。大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块。最安全的分配和使用动态内存的方法是调用make_shared标准库函数，此函数在动态分配内存中分配一个对象并初始化它，返回对象的shared_ptr。<br>参考：<a href="https://www.cnblogs.com/wxquare/p/4759020.html" target="_blank" rel="noopener">https://www.cnblogs.com/wxquare/p/4759020.html</a></li></ul><p>注：<br>1.引用计数问题</p><ul><li>每个shared_ptr所指向的对象都有一个引用计数，它记录了有多少个shared_ptr指向自己</li><li>shared_ptr的析构函数：递减它所指向的对象的引用计数，如果引用计数变为0，就会销毁对象并释放相应的内存</li><li>引用计数的变化：决定权在shared_ptr，而与对象本身无关<br>参考：<a href="https://www.cnblogs.com/xzxl/p/7852597.html" target="_blank" rel="noopener">https://www.cnblogs.com/xzxl/p/7852597.html</a></li></ul><p>2.智能指针支持的操作</p><ul><li>使用重载的-&gt;和*运算符访问对象。</li><li>使用get成员函数获取原始指针，提供对原始指针的直接访问。你可以使用智能指针管理你自己的代码中的内存，还能将原始指针传递给不支持智能指针的代码。</li><li>使用删除器定义自己的释放操作。</li><li>使用release成员函数的作用是放弃智能指针对指针的控制权，将智能指针置空，并返回原始指针。（只支持unique_ptr）</li><li>使用reset释放智能指针对对象的所有权。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    base(<span class="keyword">int</span> _a): a(_a)    &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"构造函数"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~base()    &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"析构函数"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;base&gt; up1(<span class="keyword">new</span> base(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// unique_ptr&lt;base&gt; up2 = up1;   //编译器提示未定义</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;base&gt; up2 = move(up1);  <span class="comment">//转移对象的所有权 </span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;up1-&gt;a&lt;&lt;endl; //运行时错误 </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;up2-&gt;a&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//通过解引用运算符获取封装的原始指针 </span></span><br><span class="line">    up2.reset(); <span class="comment">// 显式释放内存 </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;base&gt; sp1(<span class="keyword">new</span> base(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;base&gt; sp2 = sp1;  <span class="comment">//增加引用计数 </span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"共享智能指针的数量："</span>&lt;&lt;sp2.use_count()&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//2</span></span><br><span class="line">    sp1.reset();  <span class="comment">//</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"共享智能指针的数量："</span>&lt;&lt;sp2.use_count()&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sp2-&gt;a&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">auto</span> sp3 = make_shared&lt;base&gt;(<span class="number">4</span>);<span class="comment">//利用make_shared函数动态分配内存 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.智能指针的陷阱（循环引用等问题）<br>链接:<a href="https://blog.csdn.net/y1196645376/article/details/53023848" target="_blank" rel="noopener">https://blog.csdn.net/y1196645376/article/details/53023848</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">　　<span class="built_in">shared_ptr</span>&lt;B&gt; m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">　　<span class="built_in">shared_ptr</span>&lt;A&gt; m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="built_in">shared_ptr</span>&lt;A&gt; a(<span class="keyword">new</span> A);  <span class="comment">//new出来的A的引用计数此时为1</span></span><br><span class="line">　　　　<span class="built_in">shared_ptr</span>&lt;B&gt; b(<span class="keyword">new</span> B);  <span class="comment">//new出来的B的引用计数此时为1</span></span><br><span class="line">　　　　a-&gt;m_b = b;              <span class="comment">//B的引用计数增加为2</span></span><br><span class="line">　　　　b-&gt;m_a = a;              <span class="comment">//A的引用计数增加为2</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="comment">//b先出作用域，B的引用计数减少为1，不为0；</span></span><br><span class="line">　　<span class="comment">//所以堆上的B空间没有被释放，且B持有的A也没有机会被析构，A的引用计数也完全没减少</span></span><br><span class="line"></span><br><span class="line">　　<span class="comment">//a后出作用域，同理A的引用计数减少为1，不为0，所以堆上A的空间也没有被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>循环引用”简单来说就是：两个对象互相使用一个shared_ptr成员变量指向对方会造成循环引用。<br>即A内部有指向B，B内部有指向A，这样对于A，B必定是在A析构后B才析构，对于B，A必定是在B析构后才析构A，这就是循环引用问题，违反常规，导致内存泄露。</p><p>解决循环引用方法：<br>1.当只剩下最后一个引用的时候需要手动打破循环引用释放对象。<br>2.当A的生存期超过B的生存期的时候，B改为使用一个普通指针指向A。<br>3.使用weak_ptr打破这种循环引用，因为weak_ptr不会修改计数器的大小，所以就不会产生两个对象互相使用一个shared_ptr成员变量指向对方的问题，从而不会引起引用循环。</p><p>42.vector扩容原理说明</p><ul><li>新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；</li><li>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；</li><li>初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；</li><li>不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</li></ul><ol><li>vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。</li><li>为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，因为更好。</li></ol><p>参考链接：<a href="https://blog.csdn.net/yangshiziping/article/details/52550291" target="_blank" rel="noopener">https://blog.csdn.net/yangshiziping/article/details/52550291</a></p><p>43.内联函数和宏定义的区别<br>1.宏定义不是函数，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率。<br>内联函数本质上是一个函数，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。如果内联函数的函数体过大，编译器会自动      的把这个内联函数变成普通函数。</p><ol><li><p>宏定义是在预处理的时候把所有的宏名用宏体来替换，简单的说就是字符串替换<br>内联函数则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率</p></li><li><p>宏定义是没有类型检查的，无论对还是错都是直接替换<br>内联函数在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等</p></li></ol><p>4.宏定义和内联函数使用的时候都是进行代码展开。不同的是宏定义是在预编译的时候把所有的宏名替换，内联函数则是在编译阶段把所有调用内联函数的地方把内联函数插入。这样可以省去函数压栈退栈，提高了效率</p><p>44.内联函数与普通函数的区别</p><ol><li><p>内联函数和普通函数的参数传递机制相同，但是编译器会在每处调用内联函数的地方将内联函数内容展开，这样既避免了函数调用的开销又没有宏机制的缺陷。</p></li><li><p>普通函数在被调用的时候，系统首先要到函数的入口地址去执行函数体，执行完成之后再回到函数调用的地方继续执行，函数始终只有一个复制。<br>内联函数不需要寻址，当执行到内联函数的时候，将此函数展开，如果程序中有N次调用了内联函数则会有N次展开函数代码。</p></li><li><p>内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句。如果内联函数函数体过于复杂，编译器将自动把内联函数当成普通函数来执行。</p></li></ol><p>45.C++中成员函数能够同时用static和const进行修饰？<br>不能。</p><p>C++编译器在实现const的成员函数（const加在函数右边）的时候为了确保该函数不能修改类的中参数的值，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。</p><p>即：static修饰的函数表示该函数是属于类的，而不是属于某一个对象的，没有this指针。const修饰的函数表示该函数不能改变this中的内容，会有一个隐含的const this指针。两者是矛盾的。</p><p>46.溢出，越界，泄漏<br>1.溢出</p><p>要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。</p><p>1）栈溢出</p><p>a.栈溢出是指函数中的局部变量造成的溢出（注：函数中形参和函数中的局部变量存放在栈上）<br>栈的大小通常是1M-2M,所以栈溢出包含两种情况，一是分配的的大小超过栈的最大值，二是分配的大小没有超过最大值，但是接收的buff比新buff小（buff：缓冲区, 它本质上就是一段存储数据的内存）</p><p>例子1：（分配的的大小超过栈的最大值）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">99999999999999999</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>例子2：（接收的buff比新buff小）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="built_in">strcpy</span>(a, <span class="string">"abjjijjlljiojohihiihiiiiiiiiiiiiiiiiiiiiiiiiii"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：调试时栈溢出的异常要在函数调用结束后才会检测到，因为栈是在函数结束时才会开始进行出栈操作。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(a, <span class="string">"abjjijjlljiojohihiihiiiiiiiiiiiiiiiiiiiiiiiiii"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面情况是检测不到栈溢出的，因为函数还没执行完就退出了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(a, <span class="string">"abjjijjlljiojohihiihiiiiiiiiiiiiiiiiiiiiiiiiii"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fun();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种情况调用完fun函数就会检测到异常了</p><p>b.栈溢出的解决办法</p><p>如果是超过栈的大小时，那就直接换成用堆；如果是不超过栈大小但是分配值小的，就增大分配的大小</p><p>2）内存溢出</p><p>使用malloc和new分配的内存，在拷贝时接收buff小于新buff时造成的现象</p><p>解决：增加分配的大小</p><p>2.越界</p><p>越界通常指的是数组越界，如</p><p>char a[9]={0};</p><p>cout &lt;&lt; a[9] &lt;&lt; endl;</p><p>3.泄漏</p><p>这里泄漏通常是指堆内存泄漏，是指使用malloc和new分配的内存没有释放造成的</p><p>47.C/C++中分配内存的方法<br>1) malloc 函数： void *malloc(unsigned int size)</p><pre><code> 在内存的动态分配区域中分配一个长度为size的连续空间，如果分配成功，则返回所分配内存空间的首地址，否则返回NULL，申请的内存不会进行初始化。</code></pre><p>2）calloc 函数： void *calloc(unsigned int num, unsigned int size)</p><pre><code> 按照所给的数据个数和数据类型所占字节数，分配一个 num * size 连续的空间。calloc申请内存空间后，会自动初始化内存空间为 0，但是malloc不会进行初始化，其内存空间存储的是一些随机数据。 </code></pre><p>3）realloc 函数： void <em>realloc(void </em>ptr, unsigned int size)<br>    动态分配一个长度为size的内存空间，并把内存空间的首地址赋值给ptr，把ptr内存空间调整为size。</p><pre><code>申请的内存空间不会进行初始化。</code></pre><p>4）new是动态分配内存的运算符，自动计算需要分配的空间，在分配类类型的内存空间时，同时调用类的构造函数，对内存空间进行初始化，即完成类的初始化工作。动态分配内置类型是否自动初始化取决于变量定义的位置，在函数体外定义的变量都初始化为0，在函数体内定义的内置类型变量都不进行初始化。</p><p>48.构造函数初始化列表<br>构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">float</span> b;</span><br><span class="line"><span class="comment">//构造函数初始化列表</span></span><br><span class="line">CExample() : a(<span class="number">0</span>), b(<span class="number">8.8</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数内部赋值</span></span><br><span class="line">CExample()</span><br><span class="line">&#123;</span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = <span class="number">8.8</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>上面的例子中两个构造函数的结果是一样的。上面的构造函数（使用初始化列表的构造函数）显式的初始化类的成员；而没使用初始化列表的构造函数是对类的成员赋值，并没有进行显式的初始化。</p><p>初始化和赋值对内置类型的成员没有什么大的区别，像上面的任一个构造函数都可以。对非内置类型成员变量，为了避免两次构造，推荐使用类构造函数初始化列表。但有的时候必须用带有初始化列表的构造函数：<br>1.成员类型是没有默认构造函数的类。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。<br>2.const成员或引用类型的成员。因为const对象或引用类型只能初始化，不能对他们赋值。 </p><p>初始化数据成员与对数据成员赋值的含义是什么？有什么区别？<br>首先把数据成员按类型分类并分情况说明:<br>1.内置数据类型，复合类型（指针，引用）<br>    在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的<br>2.用户定义类型（类类型）<br>    结果上相同，但是性能上存在很大的差别。因为类类型的数据成员对象在进入函数体前已经构造完成（先进行了一次隐式的默认构造函数调用），也就是说在成员初始化列表处进行构造对象的工作，调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用了拷贝赋值操作符才能完成（如果并未提供，则使用编译器提供的默认按成员赋值行为）。</p><p>49.vector中v[i]与v.at(i)的区别<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">v[<span class="number">5</span>];<span class="comment">// A</span></span><br><span class="line">v.at[<span class="number">5</span>]; <span class="comment">// B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果v非空，A行和B行没有任何区别。如果v为空，B行会抛出std::out_of_range异常，A行的行为未定义。</p><p>c++标准不要求vector<T>::operator[]进行下标越界检查，原因是为了效率，总是强制下标越界检查会增加程序的性能开销。设计vector是用来代替内置数组的，所以效率问题也应该考虑。不过使用operator[]就要自己承担越界风险了。</T></p><p>如果需要下标越界检查，请使用at。但是请注意，这时候的性能也是响应的会受影响，因为越界检查增加了性能的开销。</p><p>50.指向函数的指针—函数指针<br>链接:<a href="https://blog.csdn.net/str999_cn/article/details/78591369" target="_blank" rel="noopener">https://blog.csdn.net/str999_cn/article/details/78591369</a></p><p>51.C++中调用C的函数<br>链接地址:<br><a href="https://www.cnblogs.com/shijiaqi1066/p/6349243.html" target="_blank" rel="noopener">https://www.cnblogs.com/shijiaqi1066/p/6349243.html</a></p><p>52.指针常量与常量指针<br>常量指针(被指向的对象是常量)<br>定义：又叫常指针，可以理解为常量的指针，指向的是个常量</p><p>关键点：</p><ol><li>常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改；</li><li>常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值；</li><li>指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p或<span class="keyword">int</span> <span class="keyword">const</span> *p</span><br></pre></td></tr></table></figure><p>(记忆技巧：const读作常量，*读作指针）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 常量指针(被指向的对象是常量)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p); <span class="comment">//10</span></span><br><span class="line">i = <span class="number">9</span>;<span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line"><span class="comment">//Error,*p是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line"><span class="comment">//*p = 11;  //error: assignment of read-only location ‘*p’</span></span><br><span class="line">p = &amp;i2;<span class="comment">//OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p); <span class="comment">//11</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针常量(指针本身是常量)<br>定义：<br>本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。</p><p>关键点：</p><ol><li>它是个常量！</li><li>指针所保存的地址可以改变，然而指针所指向的值却不可以改变；</li><li>指针本身是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针常量(指针本身是常量)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p); <span class="comment">//10</span></span><br><span class="line"><span class="comment">//Error,因为p是const 指针，因此不能改变p指向的内容</span></span><br><span class="line"><span class="comment">//p++;//error: increment of read-only variable ‘p’</span></span><br><span class="line">(*p)++;<span class="comment">//OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p); <span class="comment">//11</span></span><br><span class="line">i = <span class="number">9</span>;<span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>53.防止头文件被重复包含<br>链接地址:<a href="https://blog.csdn.net/shufac/article/details/24334601" target="_blank" rel="noopener">https://blog.csdn.net/shufac/article/details/24334601</a></p><p>54.详解拷贝构造函数相关知识<br>链接地址:<a href="https://www.cnblogs.com/alantu2018/p/8459250.html" target="_blank" rel="noopener">https://www.cnblogs.com/alantu2018/p/8459250.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是对C++语言在使用上的一些细节内容的整理,并对内容进行了相应的整理，如有不足之处欢迎批评指正，内容主要来源于博客:&lt;a href=&quot;https://www.cnblogs.com/inception6-lxc/p/8686156.html。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/inception6-lxc/p/8686156.html。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://tingyuxuan.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://tingyuxuan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++运算符重载之前加加和后加加处理细节</title>
    <link href="http://tingyuxuan.com/2019/11/18/C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B9%8B%E5%89%8D%E5%8A%A0%E5%8A%A0%E5%92%8C%E5%90%8E%E5%8A%A0%E5%8A%A0%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82/"/>
    <id>http://tingyuxuan.com/2019/11/18/C-运算符重载之前加加和后加加处理细节/</id>
    <published>2019-11-18T10:39:32.000Z</published>
    <updated>2019-11-18T10:39:32.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、来自基本数据类型的启发"><a href="#一、来自基本数据类型的启发" class="headerlink" title="一、来自基本数据类型的启发"></a>一、来自基本数据类型的启发</h4><p>运算符重载的一个重要目的就是使得自定义的数据类型对象拥有基本数据类型的运算能力和运算方法。运算符重载的一个要求之一：在对某一自定义类型的数据进行运算符重载时不能改变运算符运算的优先级。因此为了研究前加加和后加加运算符之间的区别，本文首先以int类型的变量出发研究基本数据前加加和后加加的区别。<br><a id="more"></a></p><p>结论一：如果未与其他运算结合参与运算，前加加和后加加的执行的结果是一致的；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"前加加的i++的执行次数："</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"=======================\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"后加加的i++的执行次数："</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、来自基本数据类型的启发&quot;&gt;&lt;a href=&quot;#一、来自基本数据类型的启发&quot; class=&quot;headerlink&quot; title=&quot;一、来自基本数据类型的启发&quot;&gt;&lt;/a&gt;一、来自基本数据类型的启发&lt;/h4&gt;&lt;p&gt;运算符重载的一个重要目的就是使得自定义的数据类型对象拥有基本数据类型的运算能力和运算方法。运算符重载的一个要求之一：在对某一自定义类型的数据进行运算符重载时不能改变运算符运算的优先级。因此为了研究前加加和后加加运算符之间的区别，本文首先以int类型的变量出发研究基本数据前加加和后加加的区别。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++完美转发问题---perfect forwarding</title>
    <link href="http://tingyuxuan.com/2019/11/17/C-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E9%97%AE%E9%A2%98-perfect-forwarding/"/>
    <id>http://tingyuxuan.com/2019/11/17/C-完美转发问题-perfect-forwarding/</id>
    <published>2019-11-16T16:30:20.000Z</published>
    <updated>2019-11-16T16:30:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、语义</strong><br>右值引用类型是独立于值的，一个右值引用参数作为函数的形参，在函数内部再转发该参数的时候它已经变成一个左值了，并不是它原来的类型了。因此，我们需要一种方法能按照参数原来的类型转发到另一个函数，这种转发被称为完美转发。所谓完美转发（perfect forwarding），是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数。</p><a id="more"></a><p>c++11中提供了这样的一个函数std::forward，它是为转发而生的，它会按照参数本来的类型来转发出去，不管参数类型是T&amp;&amp;这种未定的引用类型还是明确的左值引用或者右值引用。</p><p><strong>二、测试</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintT</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"lvaue"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintT</span><span class="params">(T &amp;&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestForward</span><span class="params">(T &amp;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PrintT(v);</span><br><span class="line">PrintT(<span class="built_in">std</span>::forward&lt;T&gt;(v));</span><br><span class="line">PrintT(<span class="built_in">std</span>::move(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">TestForward(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"=============="</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">TestForward(x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"=============="</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">TestForward(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(x));</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三、分析</strong><br>TestForward(1);由于 1 是右值， 所以未定的引用类型 T &amp;&amp; v 被一个右值初始化后变成了一个右值引用， 但是在 TestForward 函数体内部， 调用 PrintT(v);时， v 又变成了一个左值， 因为它这里已经变成了一个具名的变量， 所以它是一个左值， 因此第一个 PrintT 被调用， 打印出”lvaue”；</p><p>PrintT(std::forward<T>(v));由于 std::forward 会按参数原来的类型转发， 因此， 这时它还是一个右值（这里已经发生了类型推导， 所以这里的 T&amp;&amp;不是一个未定的引用类型） ，所以会调用 void PrintT(T &amp;&amp;t)函数。</T></p><p>PrintT(std::move(v));是将 v 变成一个右值引用， 虽然它本来也是右值引用， 因此它和PrintT(std::forward<T>(v));的输出结果是一样的。</T></p><p><strong>四、引用折叠（Reference collapsing）规则</strong><br>1.所有的右值引用叠加到右值引用上变成一个右值引用<br>2.所有的其它引用类型叠加都变成一个左值引用<br>3.左值或者右值是独立于它的类型的， 也就是说一个右值引用类型的左值是合法的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一、语义&lt;/strong&gt;&lt;br&gt;右值引用类型是独立于值的，一个右值引用参数作为函数的形参，在函数内部再转发该参数的时候它已经变成一个左值了，并不是它原来的类型了。因此，我们需要一种方法能按照参数原来的类型转发到另一个函数，这种转发被称为完美转发。所谓完美转发（perfect forwarding），是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另外一个函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://tingyuxuan.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://tingyuxuan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Rust语言中的指针从C语言指针的角度分析</title>
    <link href="http://tingyuxuan.com/2019/11/15/Rust%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E4%BB%8EC%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>http://tingyuxuan.com/2019/11/15/Rust语言中的指针从C语言指针的角度分析/</id>
    <published>2019-11-15T12:30:10.000Z</published>
    <updated>2019-11-15T12:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h4><p>从Rust的角度并不存在指针这个概念，Rust的理念之一就是规避C语言对内存的赤裸操作导致的一些内存泄漏等问题。Rust语言使用引用借用机制对地址进行管理。引用借用以及解引用本身就是对指针的包装，因此就目前来看引用与借用与C语言之间的关系还是很明显的，下面就一些简单实例对该问题进行分析。</p><a id="more"></a><h5 id="引用转换为指针"><a href="#引用转换为指针" class="headerlink" title="引用转换为指针"></a>引用转换为指针</h5><p>在Rust语言中我们知道可以使用关键字as进行类型转换，我们可以使用as的方法将普通的引用转换为指针，示例代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//const类型的指针</span></span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//方法一：直接转换</span></span><br><span class="line">    <span class="keyword">let</span> ptr_direct = &amp;x <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, ptr_direct);<span class="comment">//以16进制的方式显示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：间接转换</span></span><br><span class="line">    <span class="keyword">let</span> xx = &amp;x;</span><br><span class="line">    <span class="keyword">let</span> ptr_ind = xx <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, ptr_ind);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//mut类型的指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> y: <span class="built_in">i32</span> = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//方法一：直接转换</span></span><br><span class="line">    <span class="keyword">let</span> ptr_direct_y = &amp;<span class="keyword">mut</span> y <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, ptr_direct_y);<span class="comment">//以16进制的方式显示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：间接转换</span></span><br><span class="line">    <span class="keyword">let</span> yy = &amp;<span class="keyword">mut</span> y;</span><br><span class="line">    <span class="keyword">let</span> ptr_ind_y = yy <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:p&#125;"</span>, ptr_ind_y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="楷体"> 编译执行结果:</font><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x8ffadc</span></span><br><span class="line"><span class="number">0x8ffadc</span></span><br><span class="line"><span class="number">0x8ffb9c</span></span><br><span class="line"><span class="number">0x8ffb9c</span></span><br></pre></td></tr></table></figure></p><h4 id="Rust的引用设计"><a href="#Rust的引用设计" class="headerlink" title="Rust的引用设计"></a>Rust的引用设计</h4><p>C语言中存在两种重要的指针一种是指针变量指向的内容不发生变化T <em> const p；另一种是指针变量的指向不发生变化即const T </em> const p；</p><h5 id="Rust对C语言const-T-const-p的设计"><a href="#Rust对C语言const-T-const-p的设计" class="headerlink" title="Rust对C语言const T *const p的设计"></a>Rust对C语言const T *const p的设计</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> ptr = &amp;x <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;<span class="comment">//不可变绑定 对变量取地址,此时ptr因为是不可变绑定因此ptr的值不会发生变话,即指向不发生变化</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"ptr=&#123;:p&#125;"</span>, ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> val = <span class="keyword">unsafe</span> &#123; *ptr &#125;;<span class="comment">// unsafe&#123;...&#125; 对指针进行解引用 读取内存空间的数据</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"val=&#123;:?&#125;"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="楷体"> 编译执行结果:</font><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr=<span class="number">0x8ffba4</span></span><br><span class="line">val=<span class="number">5</span></span><br></pre></td></tr></table></figure></p><h5 id="Rust对C语言T-const-p的设计"><a href="#Rust对C语言T-const-p的设计" class="headerlink" title="Rust对C语言T *const p的设计"></a>Rust对C语言T *const p的设计</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可变绑定,对变量取地址，即ptr为mut 其指向可以发生变化</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> ptr = &amp;x <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"ptr = &#123;:p&#125;"</span>, ptr);<span class="comment">//此时的ptr指向x</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解地址读取内存空间的数据</span></span><br><span class="line">    <span class="keyword">let</span> val = <span class="keyword">unsafe</span> &#123; *ptr &#125;;  <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">let</span> val = <span class="keyword">unsafe</span> &#123; *ptr = <span class="number">3</span> &#125;;  <span class="comment">//改变ptr中的内容操作失败 error</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"*ptr = &#123;:?&#125;"</span>, val);<span class="comment">//ptr指向x unsafe操作之后显然为x的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新指向其他变量标记的内存地址</span></span><br><span class="line">    ptr = &amp;y;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"ptr = &#123;:p&#125;"</span>, ptr);<span class="comment">//此时的ptr指向y</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"*ptr = &#123;:?&#125;"</span>, <span class="keyword">unsafe</span> &#123; *ptr &#125;);<span class="comment">//ptr指向y unsafe操作之后显然为y的值  ok</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"*ptr = &#123;:?&#125;"</span>, <span class="keyword">unsafe</span> &#123; *ptr = <span class="number">444</span> &#125;);<span class="comment">//改变ptr中的内容操作失败 error</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="楷体"> 编译执行结果:</font><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*ptr = <span class="number">2</span></span><br><span class="line">*ptr = <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h4 id="Rust中const指针和mut类型的指针相互转换-as-const-T-lt-gt-as-mut-T"><a href="#Rust中const指针和mut类型的指针相互转换-as-const-T-lt-gt-as-mut-T" class="headerlink" title="Rust中const指针和mut类型的指针相互转换 as const T &lt;==&gt;as  mut T"></a>Rust中const指针和mut类型的指针相互转换 as <em>const T &lt;==&gt;as </em> mut T</h4><h5 id="mut类型的变量与指针变量"><a href="#mut类型的变量与指针变量" class="headerlink" title="mut类型的变量与指针变量"></a>mut类型的变量与指针变量</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 直接定义mut可变绑定类型变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取可变绑定类型变量的内存地址</span></span><br><span class="line">    <span class="keyword">let</span> ptr = &amp;<span class="keyword">mut</span> x <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取地址空间中的数据</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"*ptr = &#123;:?&#125;"</span>, <span class="keyword">unsafe</span> &#123; *ptr &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改地址空间中的数据</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123; *ptr = <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"*ptr = &#123;:?&#125;"</span>, <span class="keyword">unsafe</span> &#123; *ptr &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="楷体"> 编译执行结果:</font><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*ptr = <span class="number">2</span></span><br><span class="line">*ptr = <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h5 id="as-const-T-gt-as-mut-T"><a href="#as-const-T-gt-as-mut-T" class="headerlink" title="as *const T ==&gt;as * mut T"></a>as *const T ==&gt;as * mut T</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 栈帧上局部变量</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *const T 类型指针</span></span><br><span class="line">    <span class="keyword">let</span> ptr1 = &amp;x <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="comment">// let ptr1 : *const i32 = &amp;x as *const i32; // 同上</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"*ptr1 = &#123;:?&#125;"</span>, <span class="keyword">unsafe</span> &#123; *ptr1 &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *const T =&gt; *mut T</span></span><br><span class="line">    <span class="keyword">let</span> ptr2 = ptr1 <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 *mut T 类型指针变量指向的内存空间中的数据</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123; *ptr2 = <span class="number">6</span> &#125;;<span class="comment">//可以修改 ok</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"*ptr2 = &#123;:?&#125;"</span>, <span class="keyword">unsafe</span> &#123; *ptr2 &#125;);<span class="comment">//打印的值由5变成了6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="楷体"> 编译执行结果:</font><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*ptr1 = <span class="number">5</span></span><br><span class="line">*ptr2 = <span class="number">6</span></span><br></pre></td></tr></table></figure></p><h5 id="as-mut-T-gt-as-const-T"><a href="#as-mut-T-gt-as-const-T" class="headerlink" title="as * mut T ==&gt; as *const T"></a>as * mut T ==&gt; as *const T</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 栈帧上局部变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> y = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *mut T 类型指针</span></span><br><span class="line">    <span class="keyword">let</span> ptr1 = &amp;<span class="keyword">mut</span> y <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="comment">// let ptr1 : *mut  i32 = &amp;mut y as *mut i32; // 同上</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"*ptr1 = &#123;:?&#125;"</span>, <span class="keyword">unsafe</span> &#123; *ptr1 &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *mut T  =&gt; *const T</span></span><br><span class="line">    <span class="keyword">let</span> ptr2 = ptr1 <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 *const T 类型指针变量指向的内存空间中的数据,因为此时为*const T类型</span></span><br><span class="line">    <span class="comment">//unsafe &#123; *ptr2 = 6 &#125;;//error 无法修改</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"*ptr2 = &#123;:?&#125;"</span>, <span class="keyword">unsafe</span> &#123; *ptr2 &#125;);<span class="comment">//打印的值还是为100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="楷体"> 编译执行结果:</font><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*ptr1 = <span class="number">100</span></span><br><span class="line">*ptr2 = <span class="number">100</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;引用与指针&quot;&gt;&lt;a href=&quot;#引用与指针&quot; class=&quot;headerlink&quot; title=&quot;引用与指针&quot;&gt;&lt;/a&gt;引用与指针&lt;/h4&gt;&lt;p&gt;从Rust的角度并不存在指针这个概念，Rust的理念之一就是规避C语言对内存的赤裸操作导致的一些内存泄漏等问题。Rust语言使用引用借用机制对地址进行管理。引用借用以及解引用本身就是对指针的包装，因此就目前来看引用与借用与C语言之间的关系还是很明显的，下面就一些简单实例对该问题进行分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Rust" scheme="http://tingyuxuan.com/categories/Rust/"/>
    
    
      <category term="Rust" scheme="http://tingyuxuan.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>C++中的隐式转换和显示转换</title>
    <link href="http://tingyuxuan.com/2019/11/11/C-%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2/"/>
    <id>http://tingyuxuan.com/2019/11/11/C-中的隐式转换和显示转换/</id>
    <published>2019-11-11T02:58:19.000Z</published>
    <updated>2019-11-11T02:58:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>类型转换是一门计算机语言所具有的的重要的功能，类型的转换设计到数据的安全问题因此必须受到重视。c++语言继承了c语言的精髓并在其基础上增加了新的内容在类型转换机制上存在显示转换和因式转换两种类型。<br><a id="more"></a></p><p>首先，c++中存在隐式转换和显示转换两种转换机制。其次，在编程实践中最好在对数据对象设计变量属性的时候选择适当的类型，尽量避免类型转换或者在无法避免使用转换机制时候使用显示类型转换。</p><p><font face="楷体">隐式类型转换和现实类型转换的直观理解：</font><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>/<span class="number">8</span> <span class="number">5.0</span>/<span class="number">8</span><span class="comment">//隐式类型转换</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(<span class="number">5</span>)/<span class="number">8</span> <span class="comment">//显式类型转换</span></span><br></pre></td></tr></table></figure></p><h4 id="一、隐式类型转换"><a href="#一、隐式类型转换" class="headerlink" title="一、隐式类型转换"></a>一、隐式类型转换</h4><p><strong>定义：</strong>隐式类型转换是系统根据程序的需要自动的转换<br><strong>注意：</strong><br>    <strong>·</strong>在算术表达式中存在由低字节数据类型到高字节数据类型的转换（安全的转换）<br>    <strong>·</strong>算术表达式隐式转换顺序为： 1、char -&gt; int -&gt; long -&gt; double;2、float -&gt; double</p><p><strong>1.转换的常见的几种场景</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.算术表达式</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> n = m;<span class="comment">//n = 10.0;隐式把m转为double类型</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">10.0</span>;</span><br><span class="line"><span class="keyword">double</span> d = m + f;<span class="comment">//n = 20.0;隐式把m和f转为double类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.赋值</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//NULL(0)隐式转换为int*类型的空指针值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.函数入参</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span> f)</span></span>;  </span><br><span class="line">add(<span class="number">2</span>); <span class="comment">//2隐式转换为float类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> a - b; <span class="comment">//返回值隐式转换为double类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2.c++类对象的隐式转换</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(CTest test)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    CTest(<span class="keyword">int</span> m = <span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line">fun(<span class="number">20</span>);<span class="comment">//隐式转换</span></span><br></pre></td></tr></table></figure></p><h4 id="二、显示类型转换"><a href="#二、显示类型转换" class="headerlink" title="二、显示类型转换"></a>二、显示类型转换</h4><p><strong>定义：</strong>显式转换也叫强制转换，是自己主动让这个类型转换成别的类型<br><strong>注意：</strong><br>    <strong>·</strong>在算术表达式中存在由低字节数据类型到高字节数据类型的转换（安全的转换）<br>    <strong>·</strong>算术表达式隐式转换顺序为： 1、char -&gt; int -&gt; long -&gt; double;2、float -&gt; double</p><h5 id="1-C-类型-char-int-float-long-double等-的显式转换"><a href="#1-C-类型-char-int-float-long-double等-的显式转换" class="headerlink" title="1.C++类型(char,int,float,long,double等)的显式转换"></a>1.C++类型(char,int,float,long,double等)的显式转换</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>)m;<span class="comment">//显式把m转为char类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i += <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d);<span class="comment">//显式把d转换为int类型</span></span><br></pre></td></tr></table></figure><h5 id="1-C-类对象的显式转换"><a href="#1-C-类对象的显式转换" class="headerlink" title="1.C++类对象的显式转换"></a>1.C++类对象的显式转换</h5><p>当类构造函数只有一个参数或除了第一个参数外其余参数都有默认值时，则此类有隐含的类型转换操作符(隐式转换)，但有时隐式转换并不是我们想要的，可在构造函数前加上关键字explicit，来指定显式调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(CTest test)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CTest</span><span class="params">(<span class="keyword">int</span> m = <span class="number">0</span>)</span></span>; </span><br><span class="line">&#125; </span><br><span class="line">fun(<span class="number">20</span>);<span class="comment">//error 隐式转换</span></span><br><span class="line">fun(<span class="keyword">static_cast</span>&lt;CTest&gt;(<span class="number">20</span>)); <span class="comment">//ok 显式转换</span></span><br></pre></td></tr></table></figure></p><h4 id="三、C-中类型转换机制"><a href="#三、C-中类型转换机制" class="headerlink" title="三、C++中类型转换机制"></a>三、C++中类型转换机制</h4><p>类型转换有c风格的,当然还有c++风格的。c风格的转换的格式很简单(TYPE)EXPRESSION,但是c风格的类型转换有不少的缺点,有的时候用c风格的转换是不合适的,因为它可以在任意类型之间转换,比如你可以把一个指向 const对象的指针转换成指向非const对象的指针,把一个指向基类对象的指针转换成指向一个派生类对象的指针,这两种转换之间的差别是巨大的,但是传统的c语言风格的类型转换没有区分这些。还有一个缺点就是,c 风格的转换不容易查找,他由一个括号加上一个标识符组成,而这样的东西在c++程序里一大堆。所以 c++为了克服这些缺点,引进了4新的类型转换操作符。</p><div class="table-container"><table><thead><tr><th>转换函数</th><th>解释</th></tr></thead><tbody><tr><td>static_cast</td><td>静态类型转换</td></tr><tr><td>reinterpreter_cast</td><td>重新解释类型转换</td></tr><tr><td>dynamic_cast</td><td>子类和父类之间的多态类型转换</td></tr><tr><td>const_cast</td><td>去掉const属性转换</td></tr></tbody></table></div><p><strong>1.static_cast 静态类型转换</strong></p><ul><li>static_cast&lt;目标类型&gt;（标识符）</li><li>所谓的静态,即在编译期内即可决定其类型的转换,用的也是最多的一种。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> dPi = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">int</span> num1 = (<span class="keyword">int</span>)dPi;    <span class="comment">//c语言的旧式类型转换</span></span><br><span class="line"><span class="keyword">int</span> num2 = dPi;         <span class="comment">//隐式类型转换</span></span><br><span class="line"><span class="comment">// 静态的类型转换:   </span></span><br><span class="line"><span class="comment">// 在编译的时 进⾏行基本类型的转换 能替代c⻛风格的类型转换 可以进⾏行⼀一部分检查     </span></span><br><span class="line"><span class="keyword">int</span> num3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt; (dPi); <span class="comment">//c++的新式的类型转换运算符   </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"num1:"</span> &lt;&lt; num1 &lt;&lt; <span class="string">" num2:"</span> &lt;&lt; num2 &lt;&lt; <span class="string">" num3:"</span> &lt;&lt; num3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.dynamic_cast 子类与父类之间的多态类型准换</strong></p><ul><li>dynamic_cast&lt;目标类型&gt;（标识符）</li><li>用于多态中父子类之间的多态转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"旺旺"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dohome</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"看家"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"喵喵"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dohome</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"抓老鼠"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal* base = <span class="literal">NULL</span>;</span><br><span class="line">base = <span class="keyword">new</span> Cat();</span><br><span class="line">base-&gt;cry();</span><br><span class="line"></span><br><span class="line"><span class="comment">//⽤用于将⽗父类指针转换成⼦子类，</span></span><br><span class="line">Dog*pDog = <span class="keyword">dynamic_cast</span>&lt;Dog*&gt;(base); <span class="comment">//此时转换时失败的，因为父类指针现在指向的对象是猫，所以转换狗是失败的。</span></span><br><span class="line">                                      <span class="comment">//转换失败返回空（NULL）</span></span><br><span class="line"><span class="keyword">if</span> (pDog != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pDog-&gt;cry();</span><br><span class="line">pDog-&gt;dohome();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat* pCat = <span class="keyword">dynamic_cast</span>&lt;Cat*&gt;(base); <span class="comment">//此时转换成功，成功将父类指针转换成子类指针</span></span><br><span class="line"><span class="keyword">if</span> (pCat != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pCat-&gt;cry();</span><br><span class="line">pCat-&gt;dohome();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.const_cast 去掉const属性转换</strong></p><ul><li>const_cast&lt;目标类型&gt;（标识符）:目标类型只能是指针或者引用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> A a = &#123; <span class="number">200</span> &#125;;</span><br><span class="line">A a1 = <span class="keyword">const_cast</span>&lt;A&gt;(a);    <span class="comment">//错误，const_cast 目标类型只能是引用或者指针</span></span><br><span class="line">a1.data = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">A&amp; a2 = <span class="keyword">const_cast</span>&lt;A&amp;&gt;(a);</span><br><span class="line">a2.data = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.data &lt;&lt; <span class="string">' '</span> &lt;&lt; a2.data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">A* a3 = <span class="keyword">const_cast</span>&lt;A*&gt;(&amp;a);</span><br><span class="line">a3-&gt;data = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.data &lt;&lt; <span class="string">' '</span> &lt;&lt; a3-&gt;data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp; x1 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(x);</span><br><span class="line">x1 = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span> &lt;&lt; x1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* x2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;x);</span><br><span class="line">*x2 = <span class="number">300</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span> &lt;&lt; *x2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="楷体"> <strong>注意一:</strong></font>该函数用来移除对象的常量性(cast away the constness)使用 const_cast 去除 const 限定的目的不是为了修改它的内容，使用 const_cast 去除 const 限定，通常是为了函数能够接受这个实际参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;ref)</span> <span class="comment">//别人己经写好的程序或类库</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m = <span class="number">4444</span>;</span><br><span class="line">func(<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> &amp;&gt;(m));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="楷体"> <strong>注意二:</strong></font>脱掉 const 后的引用或指针可以改吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;a = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> &amp;&gt;(x); <span class="comment">// int &amp;a = x;</span></span><br><span class="line">a = <span class="number">300</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">"---"</span> &lt;&lt; &amp;x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(&amp;x); <span class="comment">// int *p = &amp;x;</span></span><br><span class="line">*p = <span class="number">400</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">"---"</span> &lt;&lt; &amp;x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> A xx = &#123;<span class="number">1111</span>&#125;;</span><br><span class="line">A &amp;a1 = <span class="keyword">const_cast</span>&lt;A &amp;&gt;(xx);</span><br><span class="line">a1.data = <span class="number">222</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a1.data &lt;&lt; xx.data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">A *p1 = <span class="keyword">const_cast</span>&lt;A *&gt;(&amp;xx);</span><br><span class="line">p1-&gt;data = <span class="number">333</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p1-&gt;data &lt;&lt; xx.data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="楷体"> <strong>结论:</strong></font>可以改变 const 自定义类的成员变量，但是对于内置数据类型，却表现未定义行为.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Depending on the type of the referenced object, a write operation through the resulting pointer, </span><br><span class="line">reference, <span class="keyword">or</span> pointer to data member might produce undefined behavior.</span><br></pre></td></tr></table></figure></p><p><strong>4.reinterpret_cast 重新解释类型转换</strong></p><ul><li>reinterpret_cast&lt;目标类型&gt;（标识符）</li><li>数据的二进制重新解释，但是不改变其值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Animal cry"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">look</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book look "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal* a = <span class="keyword">new</span> Animal();</span><br><span class="line">a-&gt;cry();</span><br><span class="line">Book* b = <span class="keyword">reinterpret_cast</span>&lt;Book*&gt;(a);  <span class="comment">//强制类型的转换</span></span><br><span class="line">b-&gt;look();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、补充explicity的用法"><a href="#四、补充explicity的用法" class="headerlink" title="四、补充explicity的用法"></a>四、补充explicity的用法</h4><p>在使用该关键字之前我们已经了解了c++类对象的延时类型转换我们看下面一段代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">double</span> real;</span><br><span class="line">        <span class="keyword">double</span> imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 默认构造器无explicity关键字</span></span><br><span class="line">        Complex(<span class="keyword">double</span> r = <span class="number">0.0</span>, <span class="keyword">double</span> i = <span class="number">0.0</span>) : real(r), imag(i) &#123;&#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 比较操作符==，接受一个Complex的参数</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> == (Complex rhs) &#123;</span><br><span class="line">           <span class="keyword">return</span> (real == rhs.real &amp;&amp; imag == rhs.imag)? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// a Complex object</span></span><br><span class="line">    <span class="function">Complex <span class="title">com1</span><span class="params">(<span class="number">3.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (com1 == <span class="number">3.0</span>)<span class="comment">//将Complex与double类型比较</span></span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"Same"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not Same"</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出的结果为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Same</span><br></pre></td></tr></table></figure><br>上面Complex的==操作符接受的是一个Complex参数。当程序运行到com1 == 3.0时，程序会自动调用Complex的构造器并且传入参数3.0，然后得到一个新的Complex对象，再将这个新对象传给com1的==操作符。所以程序表面上看起来是Complex和double在进行比较，但实际上程序做了隐式的转化（将double转成了Complex），依然是两个Complex在比较。</p><p>在C++中如果一个类有能够被单参数所调用的构造器，那么这个构造器就被称为转化构造器——转化构造器允许从单参数到类构造的转化。C++中能够接受单参数的构造器默认都是转化构造器。那么如何避免这种隐式的转化呢？可以使用explicity关键字。使用了explicity关键字的构造器就不允许上面的隐式转化，要转化的话，只能强制转化。我们修改后的程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">double</span> real;</span><br><span class="line">        <span class="keyword">double</span> imag;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 在构造器上加入explicity关键字</span></span><br><span class="line">        explicit Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) &#123;&#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 比较操作符==，接受一个Complex的参数</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>== (Complex rhs) &#123;</span><br><span class="line">           <span class="keyword">return</span> (real == rhs.real &amp;&amp; imag == rhs.imag)? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// a Complex object</span></span><br><span class="line">    <span class="function">Complex <span class="title">com1</span><span class="params">(<span class="number">3.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if (com1 == 3.0)//编译错误</span></span><br><span class="line">    <span class="keyword">if</span> (com1 == (Complex)<span class="number">3.0</span>) <span class="comment">//Complex的构造器使用了explicity关键字，就只能进行强制转化了。</span></span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"Same"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not Same"</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在案例中，我们可以将double转化为Complex，但是必需强制转化。下面是一个赋值的案例(Complex的构造器上无 explicity 关键字)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">com1</span><span class="params">(<span class="number">3.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">Complex com2 = <span class="number">3.0</span>;<span class="comment">//将一个3.0赋值给Complex对象</span></span><br></pre></td></tr></table></figure><br>第一个语句是传入参数构造器Complex对象，这没有什么可讨论的。第二个语句将3.0赋值给了Complex对象，其实原理和上面是一样的，首先传入参数3.0到Complex的构造器构造一个临时Complex对象，然后再将临时Complex对象传给com2对象。</p><p>如果给Complex构造器加上explicity关键字，那么就变成如下的形式了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex com2 = (Complex)<span class="number">3.0</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类型转换是一门计算机语言所具有的的重要的功能，类型的转换设计到数据的安全问题因此必须受到重视。c++语言继承了c语言的精髓并在其基础上增加了新的内容在类型转换机制上存在显示转换和因式转换两种类型。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://tingyuxuan.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://tingyuxuan.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>python模块的安装方式</title>
    <link href="http://tingyuxuan.com/2019/11/08/python%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/"/>
    <id>http://tingyuxuan.com/2019/11/08/python模块的安装方式/</id>
    <published>2019-11-08T10:56:45.000Z</published>
    <updated>2019-11-08T10:56:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>python模块的安装因为网络的原因容易安装失败最好的方法是使用国内源的方法安装，自己在模块安装实践中有以下几种方法：<br><a id="more"></a></p><h4 id="whel方法安装"><a href="#whel方法安装" class="headerlink" title="whel方法安装"></a>whel方法安装</h4><p>1.将.whl格式的文件移动到C:\Users\luckydog目录下<br>2.pip install XXXX.whl即可<br>3.安装源：<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a> </p><h4 id="豆瓣源安装方式："><a href="#豆瓣源安装方式：" class="headerlink" title="豆瓣源安装方式："></a>豆瓣源安装方式：</h4><p>pip install -i <a href="https://pypi.douban.com/simple/" target="_blank" rel="noopener">https://pypi.douban.com/simple/</a> ipython<br>pip install -U <a href="https://pypi.douban.com/simple/" target="_blank" rel="noopener">https://pypi.douban.com/simple/</a> Django</p><h4 id="pycharm安装方式："><a href="#pycharm安装方式：" class="headerlink" title="pycharm安装方式："></a>pycharm安装方式：</h4><p>在pycharm软件安装方式下，可以使用清华源进行安装，效果最佳</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python模块的安装因为网络的原因容易安装失败最好的方法是使用国内源的方法安装，自己在模块安装实践中有以下几种方法：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂项" scheme="http://tingyuxuan.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="杂项" scheme="http://tingyuxuan.com/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>winows下vscode多文件编译运行配置</title>
    <link href="http://tingyuxuan.com/2019/11/08/winows%E4%B8%8Bvscode%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E9%85%8D%E7%BD%AE/"/>
    <id>http://tingyuxuan.com/2019/11/08/winows下vscode多文件编译运行配置/</id>
    <published>2019-11-08T03:29:05.000Z</published>
    <updated>2019-11-08T03:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>vscode编译器的好处在这里就不多赘述，现在开始搭建windows系统下使用cmake和Mingw64搭建完整的c/c++多文件开发环境，搭建开发环境分为以下几步：<br><a id="more"></a><br>第一步，下载文件mingw文件到本地，并将下载好的mingw文件夹下的bin目录作为环境变量配置在path路径下，本文下载mingw64版本并将其下载解压在C盘目录下。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191108114551.png" alt><br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191108114759.png" alt></p><p>第二步，在任意硬盘或者桌面建立一个用于放置项目文件的文件夹，并在文件夹里建立以下几个文件。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191108112230.png" alt></p><p>第三步，下载cmake软件，在官方网站<a href="https://cmake.org/download/" target="_blank" rel="noopener">https://cmake.org/download/</a><br>目录下为自己的操作系统windows下载最新合适的cmake安装文件进行安装并为cmake配置环境变量。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191108114707.png" alt></p><p>第四步，在.vscode文件中为vscode配置调试环境分别建立launch.json和c_cpp_properties.json文件，在launch.json文件中拷贝如下内容:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Launch CMake-built program"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;command:cmake.launchTargetPath&#125;"</span>,</span><br><span class="line">            <span class="string">"args"</span>: [],</span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">            <span class="string">"environment"</span>: [],</span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line"><span class="string">"miDebuggerPath"</span>: <span class="string">"C:\\mingw64\\bin\\gdb.exe"</span>,</span><br><span class="line"></span><br><span class="line">            <span class="string">"setupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"description"</span>: <span class="string">"Enable pretty-printing for gdb"</span>,</span><br><span class="line">                    <span class="string">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="string">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在c_cpp_properties.json中拷贝如下内容:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"MinGW64"</span>,</span><br><span class="line">            <span class="string">"intelliSenseMode"</span>: <span class="string">"gcc-x64"</span>,</span><br><span class="line">            </span><br><span class="line">            <span class="string">"includePath"</span>: [</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;/Inc/"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"browse"</span>: &#123;</span><br><span class="line">                <span class="string">"path"</span>: [</span><br><span class="line">                    <span class="string">"$&#123;workspaceFolder&#125;/Inc/"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"cStandard"</span>: <span class="string">"c11"</span>,</span><br><span class="line">            <span class="string">"cppStandard"</span>: <span class="string">"c++17"</span>,</span><br><span class="line">            <span class="string">"configurationProvider"</span>: <span class="string">"vector-of-bool.cmake-tools"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"version"</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第五步，准备插件：在vscode插件商店里下载Cmake Tools以及Cmake插件，<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191108111334.png" alt><br>下载完成之后在第二步建立文件夹下的CMakeLists.txt文件中拷贝如下内容：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 最低CMake版本要求</span><br><span class="line">cmake_minimum_required(VERSION <span class="number">3.10</span><span class="number">.0</span>)</span><br><span class="line"></span><br><span class="line"># 项目名称</span><br><span class="line">project(cmake-test)</span><br><span class="line"></span><br><span class="line"># 设置C/C++开关</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class="line"></span><br><span class="line"># 头文件路径</span><br><span class="line">include_directories(<span class="string">"Inc"</span>)</span><br><span class="line"></span><br><span class="line"># 枚举头文件</span><br><span class="line">file(GLOB_RECURSE INCLUDES <span class="string">"Inc/*.h"</span> <span class="string">"Inc/*.hpp"</span> <span class="string">"Inc/*.cpp"</span> <span class="string">"Inc/*.c"</span> )</span><br><span class="line"></span><br><span class="line"># 枚举源文件</span><br><span class="line">aux_source_directory(<span class="string">"Src"</span> SOURCES )</span><br><span class="line"></span><br><span class="line"># 输出路径</span><br><span class="line"><span class="built_in">set</span>(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line"># 生成可执行的文件</span><br><span class="line">add_executable($&#123;PROJECT_NAME&#125; $&#123;SOURCES&#125; $&#123;INCLUDES&#125;)</span><br></pre></td></tr></table></figure></p><p>第六步，在Inc文件夹中就可以编辑c/c++文件，在Src中建立main.c/main.cpp文件，按Ctrl+shift+p为该文件适配安装的cmake gcc版本，按F5完成文件的编译和运行。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191108114116.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vscode编译器的好处在这里就不多赘述，现在开始搭建windows系统下使用cmake和Mingw64搭建完整的c/c++多文件开发环境，搭建开发环境分为以下几步：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂项" scheme="http://tingyuxuan.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="杂项" scheme="http://tingyuxuan.com/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>gcc版本下载资源网站</title>
    <link href="http://tingyuxuan.com/2019/11/07/gcc%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99/"/>
    <id>http://tingyuxuan.com/2019/11/07/gcc版本下载资源网站/</id>
    <published>2019-11-07T02:51:11.000Z</published>
    <updated>2019-11-07T02:51:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>国内好用的已经编译好的gcc版本文件源地址:<a href="https://gcc-mcf.lhmouse.com/" target="_blank" rel="noopener">https://gcc-mcf.lhmouse.com/</a><br>在该页面下载相应的版本文件替换自己已经存在的mingw文件就ok，推荐!!!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;国内好用的已经编译好的gcc版本文件源地址:&lt;a href=&quot;https://gcc-mcf.lhmouse.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gcc-mcf.lhmouse.com/&lt;/a&gt;&lt;br&gt;在该页面下载相应的
      
    
    </summary>
    
    
      <category term="杂项" scheme="http://tingyuxuan.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="杂项" scheme="http://tingyuxuan.com/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>8086CPU的一些认知</title>
    <link href="http://tingyuxuan.com/2019/11/06/8086CPU%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E7%9F%A5/"/>
    <id>http://tingyuxuan.com/2019/11/06/8086CPU的一些认知/</id>
    <published>2019-11-06T06:10:17.000Z</published>
    <updated>2019-11-06T06:10:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h4><p>首先浅要介绍一下Intel CPU 的发展史吧：Intel CPU 系列，最初是4位微处理器4004，然后到到8位微处理器的8008，再到8微微处理器8080,以及稍后的16位微处理器8086，由8086开始，Intel进入现在所谓的  x86时代 。Intel 8086为16位CPU，而因为在8086之前的CPU都是8位CPU，这样也就造成了很多的外设也只支持8位，因此Intel紧接着就退出了8位的8088CPU，因此Intel 8088也就可以看做是8086的8位版本；如果是但从汇编语言的角度上来说，8086和8088是没有区别的，即8086上跑的程序可以不加修改的移植到 8088，8088上跑的程序也可以不加修改的移植到8086上，当然，还是有些特殊的地方是不同的，而这些基本上在这里可以忽略掉，在8088CPU 之后，Intel又推出了80186,80286，这两款CPU均是16位CPU，而对于80186来说，其与8086的区别可以简单的看做是80186多了几条指令而已，而80286则不同，80286的地址总线数目有了变化，在 8086, 8088, 80186上，CPU的地址总线都是20根，即可最大寻址达到1MB的寻址能力，而对于80286CPU来说，其地址总线数目达到了24根，从而最大寻址能力为16MB。</p><a id="more"></a><p>由于支持更多的物理内存寻址，因此80286便开始成为了多任务，多用户系统的核心。而后来，Intel又推出了80386，80386为32位微处理器，Intel 80x86家族的32位微处理器始于80386；同时80386也完全兼容先前的 8086/8088，80186，80286，并且80386全面支持32位数据类型和32位操作，并且80386的数据总线根数和地址总线根数均达到了32根，从而可以最大物理寻址为232即4GB 。</p><p>而之后的80486也是32位微处理器，而后又出来了Pentium和Pentium Pro等等第五代微处理器，这些处理器虽然也是32位微处理器，但是他们的数据总线和地址总线都有所扩展，比如 Pentium 的数据总线达到64位，而 Pentium Pro 的地址总线位数达到了36位 。好，关于Intel CPU的介绍就到这里了，下面就要开始回归中心，看CPU中的寄存器了，</p><p>首先，从学习的角度来说，从 8086/8088 CPU下手是不错的选择，而我这里选择的也是8086CPU而已，说实在的，像80386CPU我也还没有研究过，像奔腾这些，呵呵，扯更远了，说到底也就只能拿8086出来晒晒而已，当然，从8086开始也是学习的最佳路径 。</p><p>说了这么久，到底寄存器是什么呢？其实很简单，寄存器就是个存储信息的单元或者说是器件又或者说是容器而已，就比如内存也是一个存储介质或者说是存储单元而已，其实寄存器从理解上来说和内存差不多，只不过寄存器（这里讨论的寄存器都是CPU中的寄存器，不包括外设上的寄存器）位于CPU内部，而内存位于CPU外部，而且，寄存器比内存可是珍贵得多啊，就拿内存和硬盘来比，肯定是内存在使用上珍贵得多，是 PC 中的稀有资源，而寄存器是CPU中的稀有资源，内存和寄存器相比就像硬盘和内存相比一样 。而对于一个汇编程序员来说，CPU中主要可以使用的也就是寄存器而已，汇编程序员可以使用指令来读写CPU中的寄存器，从而可以实现对于CPU的控制，当然，不同的CPU，寄存器的个数和结构都是不一样的，比如8086CPU中，寄存器的个数也就14个而已，并且8086CPU中所有的寄存器的结构为16位，即一个寄存器中可以存放下2B即2个字节，而到了80386CPU中，寄存器的个数也比8086增多了，比如在80386中添加了系统地址寄存器等寄存器，同时寄存器的结构也变了，比如在80386中绝大多数的寄存器为32位，而有些寄存器则是16位 。</p><p>8086CPU 中寄存器总共为14个，且均为16位 。即AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES 共14个。而这14个寄存器按照一定方式又分为了通用寄存器，控制寄存器和段寄存器。</p><font face="楷体">通用寄存器</font><p>AX (Accumulator)：累加寄存器，也称之为累加器；<br>BX (Base)：基地址寄存器；<br>CX (Count)：计数器寄存器；<br>DX (Data)：数据寄存器；<br>AX，BX，CX，DX 称作为数据寄存器：</p><p>SP 和 BP 又称作为指针寄存器：<br>SP (Stack Pointer)：堆栈指针寄存器；<br>BP (Base Pointer)：基指针寄存器；</p><p>SI 和 DI 又称作为变址寄存器：<br>SI (Source Index)：源变址寄存器；<br>DI (Destination Index)：目的变址寄存器；</p><p>控制寄存器：IP (Instruction Pointer)：指令指针寄存器；<br>标志寄存器：FLAG</p><p><font face="楷体">段寄存器</font><br>CS (Code Segment)：代码段寄存器；<br>DS (Data Segment)：数据段寄存器；<br>SS (Stack Segment)：堆栈段寄存器；<br>ES (Extra Segment)：附加段寄存器；</p><h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>从上面可以知道，在 8086 CPU 中，通用寄存器有 8 个，分别是 AX，BX，CX，DX，SP，BP，SI，DI ，至于为什么给它们取名做通用寄存器，那是因为，这些个寄存器每一个都有自己专门的用途，比如 CX 作为计数寄存器，则是在使用 LOOP 指令循环时用来指定循环次数的寄存器，如果它们每一个都只有一个专用的作用，那就它们只能称之为专用寄存器了，正是因为这些个寄存器还可以用来传送数据和暂存数据，所以才称它们为通用寄存器 。下面就按顺序来一一介绍这几个通用寄存器了：</p><h5 id="数据寄存器（AX，BX，CX，DX）："><a href="#数据寄存器（AX，BX，CX，DX）：" class="headerlink" title="数据寄存器（AX，BX，CX，DX）："></a>数据寄存器（AX，BX，CX，DX）：</h5><p>数据寄存器有 AX，BX，CX，DX 四个组成，由于在8086之前的 CPU为 8 位 CPU，所以为了兼容以前的 8 位程序，在 8086 CPU 中，每一个数据寄存器都可以当做两个单独的寄存器来使用，由此，每一个 16 位寄存器就可以当做 2 个独立的 8 位寄存器来使用了 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AX 寄存器可以分为两个独立的 <span class="number">8</span> 位的 AH 和 AL 寄存器；</span><br><span class="line">BX 寄存器可以分为两个独立的 <span class="number">8</span> 位的 BH 和 BL 寄存器；</span><br><span class="line">CX 寄存器可以分为两个独立的 <span class="number">8</span> 位的 CH 和 CL 寄存器；</span><br><span class="line">DX 寄存器可以分为两个独立的 <span class="number">8</span> 位的 DH 和 DL 寄存器；</span><br></pre></td></tr></table></figure><p>除了上面4个数据寄存器以外，其他寄存器均不可以分为两个独立的8位寄存器；注意在上面标志中的“独立”二字，这两个字表明 AH 和 AL 作为 8 位寄存器使用时，可以看做它们是互不相关的，也就是看做两个完全没有联系的寄存器 X 和 Y 即可，比如指令MOV AH ,12H ，CPU 在执行时根本就不会知道 AL 中是什么鬼东西，因为它只认识 AH 。下面给出一幅 16 位数据寄存器的结构图：表示 16 位 寄存器 AX 可以表示成两个 8 位寄存器，其中 AH 表示高位的 8 位寄存器，AL 表示低位的 8 位寄存器 。</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116010431.png" alt></p><h6 id="AX寄存器"><a href="#AX寄存器" class="headerlink" title="AX寄存器"></a>AX寄存器</h6><p>如上所说，AX 的另外一个名字叫做累加寄存器或者简称为累加器，其可以分为2个独立的 8位寄存器 AH 和 AL；在写汇编程序时，AX 寄存器可以说是使用率最高的寄存器（不过，总共才那么 14 个寄存器，哪一个不经常使用咯？），既然 AX 是数据寄存器的话，那么理所当然，其可以用来存放普通的数据，由于其是 16 位寄存器，自然也就可以存放16位数据，但是因为其又可以分为2个独立的8位寄存器AH和AL所以，在 AH 和AL中又可以独立的存放2个8位的数据，可以有以下代码（即将 AX 当做普通的寄存器使用，即可以用来暂存数据）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,<span class="number">1234</span>H  ;向寄存器 AX 传入数据 <span class="number">1234</span>H</span><br><span class="line">MOV AH,<span class="number">56</span>H  ;向寄存器 AX 的高 <span class="number">8</span> 位寄存器 AH 中传入数据 <span class="number">56</span>H</span><br><span class="line">MOV AL,<span class="number">78</span>H        ;向寄存器 AX 的低 <span class="number">8</span> 位寄存器 AL 中传入数据 <span class="number">78</span>H</span><br></pre></td></tr></table></figure><p>3条语句的执行过程如下：</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116134622.png" alt></p><p>而既然 AX 又被称作为累加器，自然其还有一点点特殊的地方的：</p><p>一、AX 寄存器还具有的特殊用途是在使用DIV和MUL指令时使用，DIV在8086CPU中是除法指令，而在使用除法的时候有两种情况，即除数可以是8位或者是16位的，而且除数可以存放在寄存器中或者是内存单元中，而至于被除数的话，自然,应该由AX来代替了，当除数是8位时，被除数一定会是16位的，并且默认是放在AX寄存器中，而当除数是16位时，被除数一定是32位的，因为AX是16位寄存器，自然，放不下32位的被除数，所以，在这里还需要使用另一个16位寄存器DX，其中DX存放32位的被除数的高16位，而AX则存放32位的被除数的低16位，同时，AX的作用还不仅仅是用来保存被除数的，当除法指令执行完成以后，如果除数是8位的，则在AL中会保存此次除法操作的商，而在AH中则会保存此次除法操作的余数，当然，如果除数是16位的话，则AX中会保存本次除法操作的商，而DX则保存本次除法操作的余数。</p><p>二、上面介绍的是 AX 寄存器在除法操作中的应用，下面还需要介绍一下 AX 在乘法操作中的应用，当使用 MUL 做乘法运算时，两个相乘的数要么都是8位，要么都是16位，如果两个相乘的数都是8位的话，则一个默认是放在AL中，而另一个8位的乘数则位于其他的寄存器或者说是内存字节单元中，而如果两个相乘的数都是16位的话，则一个默认存放在AX中，另一个16位的则是位于16的寄存器中或者是某个内存字单元中。同时，当MUL指令执行完毕后，如果是8位的乘法运算，则默认乘法运算的结果是保存在AX中，而如果是16位的乘法运算的话，则默认乘法运算的结果有32位，其中，高位默认保存在DX中，而低位则默认保存在AX中。</p><p>AX 寄存器在DIV指令中的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV DX,<span class="number">0</span>H;设置 <span class="number">32</span> 位被除数的高 <span class="number">16</span> 位为 <span class="number">0</span>H</span><br><span class="line">MOV AX,<span class="number">8</span>H;设置 <span class="number">32</span> 位被除数的低 <span class="number">16</span> 位为 <span class="number">8</span>H</span><br><span class="line">MOV BX,<span class="number">2</span>H;设置 <span class="number">16</span> 位除数为 <span class="number">2</span>H</span><br><span class="line">DIV BX        ;执行计算</span><br></pre></td></tr></table></figure><p>4 条语句的执行过程如下：</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011129.png" alt></p><p>AX 寄存器在 MUL  指令中的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,<span class="number">800</span>H;设置 <span class="number">16</span> 位乘数为 <span class="number">800</span>H</span><br><span class="line">MOV BX,<span class="number">100</span>H;设置 <span class="number">16</span> 位乘数为 <span class="number">100</span>H</span><br><span class="line">MOV DX,<span class="number">0</span>H;清空用来保存乘法结果的高 <span class="number">16</span> 位    </span><br><span class="line">MUL BX        ;执行计算</span><br></pre></td></tr></table></figure><p>4 条语句的执行过程如下：</p><p><img src="/images/2019/11/16/0cbc8b60-07cb-11ea-9cf6-fb9e5c359a2c.png" alt="image.png"></p><h6 id="BX-寄存器"><a href="#BX-寄存器" class="headerlink" title="BX 寄存器"></a>BX 寄存器</h6><p>首先可以明确的是，BX作为数据寄存器，表明其是可以暂存一般的数据的，即在某种程度上，它和AX可以暂存一般性数据的功能是一样的，其同样为了适应以前的8位CPU，而可以将BX当做两个独立的8位寄存器使用，即有BH和BL，除了暂存一般性数据的功能外，BX作为通用寄存器的一种，BX主要还是用于其专属功能—寻址（寻址物理内存地址）上，BX 寄存器中存放的数据一般是用来作为偏移地址使用的，何为偏移地址呢？</p><p>既然是偏移地址的话，当然得有一个基地址了，而这个基地址其实就是段地址，这里就涉及到了段寄存器，当然，在介绍 BX 寄存器的时候，我不会去介绍段寄存器，上面提到 BX 的主要功能是用在寻址上，那么，其是如何寻址的呢？</p><p>对于寻址这个话题，我会在我的下一篇博文中作出详细的介绍，而这里，我只点一下，在8086 CPU中，CPU 是根据 &lt;段地址：偏移地址&gt; 来进行寻址操作的，而BX中存放的数据表示的是偏移地址的话，自然，便可以通过 &lt;段地址：[BX]&gt; 的方式来完成寻址操作了。</p><p>为了介绍BX在寻址当中的作用，下面我给出一副示意图：</p><p><img src="/images/2019/11/16/2cd9d3d0-07cb-11ea-9cf6-fb9e5c359a2c.png" alt="image.png"></p><p>上面的示意图表示：可以令 BX = 2，然后通过DS : [BX] 来访问到内存中段地址为DS，且偏移量为2的内存单元了。</p><p>上面介绍的这种寻址方式是 BX 在寻址中最最简单的应用了，而对于稍微复杂的寻址方式，还可以依赖于 SI，DI，BP 等寄存器来一起完成，当然，这会是下一篇博文将要介绍的内容了。</p><p>BX寄存器在寻址中的使用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV BX,<span class="number">5</span>H</span><br><span class="line">MOV AH,<span class="number">11</span>H</span><br><span class="line">MOV AH,[BX];设置 AX 的值为偏移地址为 BX 中的值时所代表的内存单元</span><br></pre></td></tr></table></figure><p>3 条语句的执行过程如下：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011343.png" alt></p><p>从上图可以看出，在偏移地址为 5 时的内存单元中的数据位 BBH，<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011404.png" alt><br>而从这幅图上面就可以看出，确实通过 [BX] 找到了偏移地址为 5 处的内存单元，并且将内存单元移入了 AH 中。</p><h6 id="CX-寄存器"><a href="#CX-寄存器" class="headerlink" title="CX 寄存器"></a>CX 寄存器</h6><p>CX寄存器作为数据寄存器的一种呢，其同样具有和AX,BX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的8位寄存器使用，即有CH和CL两个8位寄存器，当然，CX也是有其专门的用途的，CX 中的C被翻译为Counting也就是计数器的功能，当在汇编指令中使用循环LOOP指令时，可以通过CX来指定需要循环的次数，而CPU在每一次执行LOOP指令的时候，都会做两件事：一件就是令CX=CX–1，即令CX 计数器自动减去1；还有一件就是判断CX中的值，如果CX中的值为0则会跳出循环，而继续执行循环下面的指令，当然如果CX中的值不为0，则会继续执行循环中所指定的指令 。</p><p>CX 寄存器在循环中的使用（输出5个白底蓝字的A）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,<span class="number">0B</span>800H</span><br><span class="line">MOV DS,AX    ;使用 <span class="number">80</span>x25 彩色字符模式，内存地址 <span class="number">0xB8000</span> - <span class="number">0xBFFFFF</span></span><br><span class="line">MOV BX,<span class="number">0</span>    ;从 <span class="number">0xB8000</span> 开始</span><br><span class="line">MOV CX,<span class="number">5</span>H    ;循环 <span class="number">5</span> 次</span><br><span class="line">MOV DX,<span class="number">41</span>H    ;A 的<span class="number">16</span> 进制为 <span class="number">41</span>H</span><br><span class="line">MOV AX,<span class="number">01110001B</span>;显示白底蓝字</span><br><span class="line">s:  MOV [BX],DX;显示 ASCII 字符</span><br><span class="line">    ADD BX,<span class="number">1</span></span><br><span class="line">    MOV [BX],AX;设置字符显示属性</span><br><span class="line">    ADD BX,<span class="number">1</span></span><br><span class="line">LOOP s</span><br></pre></td></tr></table></figure><p>语句的执行过程如下：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011455.png" alt></p><h6 id="DX-寄存器"><a href="#DX-寄存器" class="headerlink" title="DX 寄存器"></a>DX 寄存器</h6><p>DX 寄存器作为数据寄存器的一种，同样具有和 AX，BX，CX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的8位寄存器使用，极有DH和 DL，同时，DX 作为一个通用寄存器的话，自然其还有其他的用途，而关于DX在其他方面的用途，其实在前面介绍AX寄存器时便已经有所介绍了，即当在使用 DIV 指令进行除法运算时，如果除数为16位时，被除数将会是32位，而被除数的高16位就是存放在 DX 中，而且执行完 DIV 指令后，本次除法运算所产生的余数将会保存在DX中，同时，在执行 MUL 指令时，如果两个相乘的数都是 16 位的话，那么相乘后产生的结果显然需要32位来保存，而这32位的结果的高16位就是存放在 DX 寄存器中。</p><p>DX寄存器在DIV指令中的使用（即2293812 / 256 = 8960  余数为52）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV DX,<span class="number">0023</span>H;<span class="number">32</span> 位被除数的高 <span class="number">16</span> 位</span><br><span class="line">MOV AX,<span class="number">0034</span>H;<span class="number">32</span> 位被除数的低 <span class="number">16</span> 位</span><br><span class="line">MOV BX,<span class="number">100</span>H;<span class="number">16</span> 的除数</span><br><span class="line">DIV BX</span><br></pre></td></tr></table></figure><p>语句的执行过程如下：</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011529.png" alt></p><p>可以看到在语句结束以后，AX = 2300H  即十进制的 8960，而 DX = 34H即十进制的 52 和我们的结果是一致的。</p><p>DX 寄存器在 MUL  指令中的使用则各位可以参考在 AX 中 MUL 运算的使用，这里就不贴出来了。</p><h5 id="指针寄存器（BP，SP）"><a href="#指针寄存器（BP，SP）" class="headerlink" title="指针寄存器（BP，SP）"></a>指针寄存器（BP，SP）</h5><h6 id="BP-寄存器："><a href="#BP-寄存器：" class="headerlink" title="BP 寄存器："></a>BP 寄存器：</h6><p>8086  CPU 中的指针寄存器包括两个，即 SP 和 BP ，在这里呢，我先只对 BP 寄存器做介绍，因为 SP 寄存器实质上必须和 SS 段寄存器一起使用，所以，我将会把 SP 寄存器留到后面和 SS 段寄存器一起作介绍。</p><p>BP (Base Pointer)也就是基指针寄存器，它和其他的几个用来进行寻址操作所使用的寄存器（还有 BX，SI，DI）没有太大的区别，</p><p>关于 SI 和 DI 寄存器的下面请见下文。</p><p>首先，BP 寄存器作为通用寄存器的一种，说明其是可以暂存数据的，而后，BP 又不是数据寄存器，也就意味着其不能分割成 2 个独立的 8 位寄存器使用，而后当以 […] 的方式访问内存单元而且在 […] 中使用了寄存器 BP 的话，那么如果在指令中没有明确或者说是显示的给出段地址时，段地址则使用默认的 SS 寄存器中的值（BX，SI，DI 会默认使用 DS 段寄存器），比如 DS:[BP] 则在这里明确给出了段地址位于 DS 中，所以，这里代表的内存单元即是段地址为 DS ，偏移量为 BP 寄存器中的值的内存单元，而如果单单是使用 [BP] 的话，则代表的内存单元是段地址为 SS，偏移量为 BP 寄存器中的值的内存单元。</p><p>并且 BP 寄存器主要适用于给出堆栈中数据区的偏移，从而可以方便的实现直接存取堆栈中的数据，至于堆栈的话，会在后面的博文中介绍。在 8086 CPU 中，只有 4 个寄存器可以以  […]  的方式使用，这四个寄存器分别是 BX，SI，DI，BP。</p><p>下面的  Demo  是 BX 寄存器在寻址中的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV BP,<span class="number">0</span></span><br><span class="line">MOV AX,[BP]         ;将 SS:[BP] 代表的内存单元移入 AX 中</span><br><span class="line">MOV AX,CS:[BP]      ;将 CS:[BP] 代表的内存单元移入 AX 中</span><br></pre></td></tr></table></figure><p>语句的执行过程如下：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011649.png" alt></p><h5 id="变址寄存器（SI，DI）"><a href="#变址寄存器（SI，DI）" class="headerlink" title="变址寄存器（SI，DI）"></a>变址寄存器（SI，DI）</h5><p>首先，变址寄存器和上面介绍的指针寄存器（也就是 BP 和 SP），它们的功能其实都是用于存放某个存储单元地址的偏移，或者是用于某组存储单元开始地址的偏移，即作为存储器指针使用，当然，由于变址寄存器和指针寄存器都是属于通用寄存器，所以它们也可以保存算术结果或者说是具有暂存数据的功能，但是因为它们不是数据寄存器，所以无法分割成 2 个独立的 8 位寄存器使用。</p><p>关于变址寄存器和指针寄存器的详细使用，笔者将会在下一篇博文中作出最详细的介绍，</p><p>SI (Source Index) 是源变址寄存器，DI (Destination Index) 即是目的变址寄存器，8086 CPU 中的 SI 寄存器和 DI 寄存器其实和 BX 寄存器的功能是差不多的，只不过 SI 寄存器和 DI 寄存器均不是数据寄存器，所以它们不能够拆分为 2 个独立的 8 位寄存器，而这也就是 SI 寄存器和 DI 寄存器与BX 寄存器所不同的地方，既然，SI，DI 两个寄存器的功能和 BX 差不多，自然，SI 和 DI 中也是可以暂存一般性数据的，同时，通过使用 SI 和 DI 寄存器也是可以用来完成寻址操作的。</p><p>比如下面的代码就是可行的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MOV SI,<span class="number">0</span>;初始化偏移地址为 <span class="number">0</span></span><br><span class="line">MOV AX,[SI];将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,DS:[SI];将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,SS:[SI];将段地址为 SS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br><span class="line"></span><br><span class="line">MOV DI,<span class="number">0</span>    ;初始化偏移地址为 <span class="number">0</span></span><br><span class="line">MOV AX,[DI];将段地址为 DS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,DS:[DI];将段地址为 DS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,SS:[DI];将段地址为 SS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br></pre></td></tr></table></figure><h5 id="其他寄存器（CS，IP，SS，SP，DS，ES）"><a href="#其他寄存器（CS，IP，SS，SP，DS，ES）" class="headerlink" title="其他寄存器（CS，IP，SS，SP，DS，ES）"></a>其他寄存器（CS，IP，SS，SP，DS，ES）</h5><p>由于段寄存器总是和其他一些像指针寄存器，变址寄存器，控制寄存器一起使用，所以在这里，我并不会单独介绍段寄存器，而是将段寄存器和一些其他的常用寄存器搭配介绍 。由于下面的介绍中会涉及到很多关于段和栈的概念，而段和栈的介绍又都必须关系到物理内存，所以在介绍段寄存器以及其他一些呈协作关系的寄存器之前，还是先来介绍一下这几个基本的概念比较好。</p><p>8086 CPU 访问内存（物理地址）：</p><p>当 CPU 需要访问一个内存单元时，需要给出内存单元的地址，而每一个内存单元在物理内存空间中都有一个唯一的地址，即可以通过这个地址定位到内存单元，而这个地址即为物理地址。CPU 通过地址总线将一个内存单元的物理地址送入存储器，而后 CPU 便可以通过这个物理地址来访问这个物理地址所指向的内存单元了。</p><p>那么这个物理地址在 CPU 中是如何形成的呢？<br>首先，我们知道 8086 CPU 的地址总线是 20 根，即每次都可以传输 20 位的地址，从而寻址能力有 220 也就是 1MB 的大小，但是 8086 CPU 的寄存器只有 16 位，也就是在 8086 CPU 的内部，一次性处理，传输，暂存的地址都只能是 16 位，即 8086 CPU 不能完整的保存下一个物理地址（物理地址为 20 位），如果单单以最简单的方式（即直接用 16 位寄存器来保存物理地址）的话，那么，寻址能力只有 216 ，也就是 64KB，如果真以如此简单的方式的话，那么地址总线还需要 20 根干嘛呢？而且，难不成我们以后的内存就是 64KB 了吗？</p><p>当然不是的，8086 CPU 在这里采取了一定的措施从而使其寻址能力达到 1MB 。8086 CPU 在内部通过两个 16 位的地址进行合成从而形成一个 20 位的物理地址，由此，8086 CPU 的寻址能力便可以达到 1MB 。那么 8086 CPU 又是如何将两个 16 位的地址合成为一个20 位的物理地址的呢？当 CPU 在访问内存时，其会使用一个 16 位的基地址，然后再使用一个 16 位的偏移地址，通过将基地址和偏移地址传入 8086  CPU 的地址加法器中进行合成即可以构造出 20 位的物理地址。</p><p>至于合成的方式如下：</p><p>基地址其实是通过一个 16 位的段地址来形成的，将一个段地址左移 4 位即形成了基地址，而至于偏移地址的话，自然不必多说，为 16 位，通过将基地址和偏移地址相加便形成了 20 位的物理地址 。</p><p>下面给出一幅示意图来表示物理地址的合成：</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011906.png" alt></p><p>段：</p><p>至于段的话，其实在物理内存中是没有段这一概念的，事实上，段的概念来自于  CPU ，因为 CPU 拥有段寄存器，既然在 CPU 中拥有了段寄存器，自然，在 CPU 中就肯定有段的概念了，其实段也就是在编程时，我们将若干个地址连续的内存单元看做是一个段，然后通过将一个段地址左移 4 位形成基地址，再通过这个基地址来定位这个段的起始地址，然后，再通过偏移地址便可以精确定位到段中的内存单元了，由于段的起始地址是一个段地址左移 4 位，所以很明显，段的起始地址肯定是 16 的倍数，而且由于一个段内部，只能通过偏移地址来定位，而偏移地址为 16 位，所以一个段的长度也就是 216 也就是 64KB 的大小。</p><p>在编程时，可以讲一段内存定义成为一个段，而这里，我们又可以引出数据段，代码段，栈段这三种类型的段 。</p><p>何为数据段呢？其实就是我们自个儿定义一段内存（当然段起始地址肯定是 16 的倍数，并且段长度 &lt;= 64KB），然后我们在这个段里头存放我们所需要使用的数据，这就是数据段；</p><p>何为代码段呢？其实也很简单，也是我们自己在编程的时候定义一段内存，然后这段内存用来存放我们的代码（也就是指令），</p><p>既然是存放的代码，自然就称之为代码段；</p><p>何为栈段呢？至于栈段的话，有接触过数据结构的朋友应该是很清楚栈的，而这里我们也就是在内存中分配出一个段，</p><p>然后将这个段当做栈来使用，对于栈的介绍，详见下文；</p><p>这里呢，顺便还点出几个关于段寄存器的内容，当然下文还会详细介绍的，</p><p>首先，对于任何一个段来说，均有段地址，而这些段地址是存放在段寄存器中（段寄存器的作用也在于此），但是对于不同的段，它们默认的段地址存放在不同的段寄存器中，像数据段来说，它的段地址存放在  DS （Data  Segment）寄存器中，代码段的段地址存放在  CS （Code  Segment）寄存器中，栈段的段地址存放在  SS （Stack  Segment）寄存器中 。</p><p>下面给出一幅在段中寻址的示意图：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011938.png" alt></p><p>上面的示意图中，通过将段地址左移四位，然后与偏移地址相加便可以得到 20 位的物理地址了 。</p><p>栈：</p><p>8086CPU中提供了对栈的支持，并且其还提供了相应的指令来以栈的方式访问内存空间 。</p><p>什么是栈？</p><p>通过上面在段中的介绍，栈其实就是一个段，再说白一点，也就是一块内存，当然，这块内存是一块连续的内存 。既然栈是一个段的话，那么当然就可以以使用段的方式来使用栈，当然，除了像段一样的使用栈以外，栈还提供了其特殊的访问方式（如果和段一模一样的话，那还需要栈干吗呢？），</p><p>众所周知，栈是先进后出类型的数据结构，在 8086  CPU 中也是如此，可以通过 ”PUSH“  指令将数据压入栈中，然后再通过 ”POP“  指令将栈顶的元素取出来 。</p><p>下面给出一幅示意图来描述栈：</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116011957.png" alt></p><p>即通过 PUSH  10 来将元素 10 放入栈中，因为，先前栈中没有任何数据，所以，10 就会作为栈顶元素存在，然后再在栈中压入元素 20 ，此时，栈顶中的元素就是 20 了，然后再使用  POP 指令将栈顶元素取出，此时取出的栈顶元素是 20 ，取出 20 后，栈中便只剩下 10 了，自然 10 就成为了栈顶，最后再通过 POP 指令将栈顶 10 取出，此时，栈便变成了空栈了 。</p><p>好了，在介绍段寄存器之前的基础知识介绍就到这里了，下面开始正式介绍段寄存器以及与它们协作使用的寄存器。</p><p>CS 寄存器 和 IP 寄存器：</p><p>经过前面对段的介绍，相信各位朋友对段寄存器应该也有一定的了解了，下面将要介绍的是一组非常非常重要的寄存器，即 CS:IP 。CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址，其中  CS  为代码段寄存器，而IP为指令指针寄存器 。</p><p>什么叫做指示了 CPU 当前将要读取的指令呢？在 8086  CPU 中，为什么  CPU  会自动的执行指令呢？<br>这些指令肯定是存放在内存中的，但是  CPU  怎么知道这些指令存放在内存的那个位置呢？<br>比如，我有下面的两条指令要执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,<span class="number">1234</span>H</span><br><span class="line">MOV BX,AX</span><br></pre></td></tr></table></figure><p>而假设这两条指令在内存中存放为：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012102.png" alt></p><p>很显然，1000H:0000H 指向的是MOV AX，1234H的首地址，如果CPU要读取到我的指令的话，很显然，必须要知道地址1000H:0000H，然后CPU就可以根据这个首地址，将汇编指令MOV  AX，1234H所对应的机器码读入到CPU的指令寄存器中，最后便可以在CPU中进行处理了。</p><p>但关键是CPU如何知道我的1000H:0000H这个首地址？</p><p>其实这就需要使用到CS:IP这个寄存器组了。当我们运行一个可执行文件时，很明显，我们需要另外一个程序来将这个可执行文件加载到内存当中，关于这个加载可执行文件的程序，我们在这里不管他，点一下即可，一般是通过操作系统的外壳程序（也就是传说中的Shell程序），Shell将可执行文件加载到内存中以后，就会设置CPU中的两个寄存器，即设置CS:IP两个寄存器指向可执行文件的起始地址，此后CPU便从这个起始地址开始读取内存中的指令，并且执行，比如我们在写汇编程序时，通常会使用START标记，其实这个标记就是用来标记起始地址的，当将一个汇编程序编译，连接成可执行文件以后，再通过操作系统的  Shell程序将可执行文件加载到内存中以后，这个START所标记处的地址就是整个可执行文件的起始地址了 。</p><p>也就是说，当一个可执行文件加载到内存中以后，CS:IP  两个寄存器便指向了这个可执行文件的起始地址，然后  CPU  就可以从这个起始地址开始往下读取指令，当读取完指令后，CS:IP  将会自动的改变，基本上是改变  IP ，从而指向下一条要读取的指令，这样就可以执行这个可执行文件了 。</p><p>最后再对  CS:IP  总结一下：</p><p>你想让CPU执行哪行指令，你就让CS:IP指向保存有指令的那块内存即可。任何时候，CS:IP指向的地址中的内容都是CPU当前执行的指令。下面我们来看一个Demo，并详细观察其执行的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">    </span><br><span class="line">    MOV AX,<span class="number">1234</span>H</span><br><span class="line">    MOV BX,AX</span><br><span class="line">    </span><br><span class="line">    MOV AH,<span class="number">4</span>CH</span><br><span class="line">    INT <span class="number">21</span>H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><p>语句的执行过程如下：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012123.png" alt></p><p>从上面的截图中可以看出，当我使用Shell（在DOS下也就是Command命令解释器）将可执行文件加载进内存后，可以看到，整个程序的起始地址为0C54H:0000H，并且，可以看到CS的地址为0C54H，IP的地址为0000H，这正好吻合我们上面对CS:IP的分析，很明显，CPU将会读取MOV AX，1234H 到CPU中并且执行 ，然后我们继续向下看：</p><p><img src="/images/2019/11/16/6639d390-07cc-11ea-9cf6-fb9e5c359a2c.png" alt="image.png"></p><p>可以看到，我们单步执行后，AX中的值编成了1234H，而IP寄存器中的值变成了0003H，对于AX中的值的改变，我们是能够理解的，但是IP中的值为什么会从0000H变到0003H呢？</p><p>从最上面的一幅关于指令在内存中的存放可以看出MOV AX,1234H在内存中需要3个内存单元存放，也就是  CPU为了执行MOV AX，1234H这条指令，已经将内存中相对应的3个内存单元读入内存中了，执行完这条指令后，自然，CPU就要将偏移地址向下移动3个单元，从而使得CS:IP指向下一条需要执行的指令了，为了更深刻的理解，我们再来继续看执行过程，</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012211.png" alt></p><p>从最上面的一幅关于指令在内存中的存放可以看出MOV BX，AX在内存中只占2个内存单元，这也就是为什么IP这一次只向下移动了2个单元的缘故 。</p><p>关于CS:IP的遐想：</p><p>从上面关于CS:IP的介绍中，我们可以大胆的猜想，我们只需要通过手动的改变CS:IP所指向的内存地址，让CS:IP指向我们另外的代码，那么我们就可以让CPU执行我们自己指定的代码了 。即可以通过修改  CS:IP来达到我们想要让CPU干什么它就干什么的目的 。上面的虽然是遐想，但是大家要相信，我们写的是汇编，不是JAVA也不是NET，所以我们还真的可以达到上面的目的，也就是说我们的遐想其实是可以实现的，当然这还是有一定的限制的，关于这个遐想呢，可能会在我后续的博文中有所介绍，不过感兴趣的当然可以自己去尝试了，蛮有味的哦。</p><p>SS寄存器和SP寄存器：</p><p>根据前面对栈的介绍，相信各位对栈也肯定是有一定了解了的，更何况，估计大家也是职场打滚多年的，要是栈都没用过的话，那也确实蛮悲剧的 ，所以，我在这里也不会对栈做十分详细的介绍了，但是，最基本的介绍还是要的，毕竟在底层的话，不像高级语言那么方便，可以直接一个  Stack  就 OK 的，在底层涉及的是栈在内存中的具体实现 。</p><p>不知道，大伙有没有注意笔者在本篇博文的上面介绍关于栈的知识时，我并没有提到如何找到这个栈，我只提到了一个栈就是先进后出操作，同时可以使用”PUSH”和”POP”指令，然后就是稍微带了一下SS这个寄存器的介绍，</p><p>我们虽然在内存中是可以方便的定义一个栈了，但是，我们为什么要定义这么一个栈呢？自然，是为了操作方便，同时提供给CPU使用的，既然CPU要使用的话，自然，CPU又必须根据一定的方式找到这个栈，而这就需要使用SS和SP寄存器了 。</p><p>同时，一个栈也就是一块内存区域，通过上面的介绍，我们也知道了如果要在一块内存中精确地定位到内存单元的话（寻址），我们必须要有基地址（也就是段地址左移4位）和偏移地址，自然，要在一个栈中寻址的话，也需要段地址和偏移地址，</p><p>而对于一个栈来说，我们使用的最多的是什么呢？</p><p>当然是栈顶了，因为只有栈顶可以用来存取数据，所以对于一个栈来说，我们只需要有栈顶的段地址和偏移地址即可，而对于栈顶的段地址，其是存放在段寄存器SS中的，而对于栈顶的偏移地址，其则是存放在SP  寄存器中的。记住，在任何时刻，SS:SP都是指向栈顶元素。其实关于栈的使用还是比较简单的，但是要注意的是8086CPU并不会保证我们对栈的操作会不会越界。所以我们在使用栈的时候需要特别注意栈的越界问题 。</p><p>当使用  PUSH 指令向栈中压入1个字节单元时，SP = SP - 1；即栈顶元素会发生变化；而当使用PUSH指令向栈中压入2个字节的字单元时，SP = SP – 2 ；即栈顶元素也要发生变化；当使用POP指令从栈中弹出 1个字节单元时， SP = SP + 1；即栈顶元素会发生变化；当使用POP指令从栈中弹出2个字节单元的字单元时，SP = SP + 2；即栈顶元素会发生变化；</p><p>下面通过一个  Demo 来介绍栈的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">    </span><br><span class="line">    MOV AX,<span class="number">1000</span>H;首先是定义好栈的段地址</span><br><span class="line">    MOV SS,AX    </span><br><span class="line">    MOV AX,<span class="number">10</span>H;再定义好栈的长度（初始时刻的栈顶偏移地址即栈的长度）</span><br><span class="line">    MOV SP,AX</span><br><span class="line">    </span><br><span class="line">    MOV AX,<span class="number">0001</span>H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,<span class="number">0002</span>H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,<span class="number">0003</span>H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,<span class="number">0004</span>H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,<span class="number">0005</span>H</span><br><span class="line">    PUSH AX</span><br><span class="line">    </span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    MOV AH,<span class="number">4</span>CH</span><br><span class="line">    INT <span class="number">21</span>H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><p>然后我们来看栈在内存中的结构图：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012252.png" alt><br>语句的执行过程如下：</p><p>首先我们来看尚未执行上述任何指令时栈中的数据情况：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012310.png" alt><br>然后我们再来依次执行上述指令：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012327.png" alt><br>从上副截图中可以看出已经设置好了  SS:SP ，也就是栈已经设置 OK 了，下面开始往栈中压入数据了，<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012348.png" alt><br>由于我们压入栈中的数据为字数据，即占 2 个内存单元，所以，每次  SP = SP – 2 ；将 5 个字型数据压入栈中后，我们可以来查看栈中的数据了，<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012411.png" alt><br>因此，在内存中的一个好看点的结构图如下所示：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012444.png" alt><br>下面开始进行出栈操作了<br><img src="/images/2019/11/16/e404e3f0-07cc-11ea-9cf6-fb9e5c359a2c.png" alt="image.png"><br>由于我们弹出栈时的数据为字数据，即占2个内存单元，所以，每次  SP = SP + 2 ；</p><p>将5个字型数据全部弹出栈中后，我们可以来查看栈中的数据了，<br><img src="/images/2019/11/16/eeafe890-07cc-11ea-9cf6-fb9e5c359a2c.png" alt="image.png"></p><p>可以看到 SP 变成了初始状态了，也就是说栈中所有的数据已经全部弹出了，虽然我们查看内存时看到的不是 0 ，</p><p>但是我们看到的这些数据都是无效的，我们这里不理会 。</p><p>DS 寄存器和 ES 寄存器：</p><p>DS寄存器和ES寄存器都属于段寄存器，其实它们和CS寄存器以及SS寄存器用起来区别不大，既然是段寄存器的话，自然它们存放的就是某个段地址了 。</p><p>通过上面对基础知识的介绍呢，我们已经知道，如果CPU要访问一个内存单元时，我们必须要提供一个指向这个内存单元的物理地址给CPU，而我们也知道在8086CPU中，物理地址是由段地址左移4位，然后加上偏移地址形成的，所以，我们也就只需要提供段地址和偏移地址即OK 。</p><p>8086CPU呢，提供了一个DS寄存器，并且通常都是通过这个DS段寄存器来存放要访问的数据的段地址 。</p><p>DS（Data  Segment）：很显然，DS中存放的是数据段的段地址 。</p><p>但是这里不得不再点一下，那就是我们对段的支持是在CPU上体现的，而不是在内存中实现了段，所以事实上我们使用的段其实是一个逻辑概念，即是我们自己定义的，再说白了，我定义一个段，我说它是数据段那它就是数据段，我说它是代码段那么它就是代码段，它们其实都是一块连续的内存而已，至于为什么要区分为数据段和代码段，很明显，是用来给我们编程提供方便的，即我们在自己的思想上或者说是编码习惯上规定，</p><p>数据放数据段中，代码放代码段中 。而我们在使用数据段的时候，为了方便或者说是代码的编写方便起见，我们一般把数据段的段地址放在DS寄存器中，当然，如果你硬要觉得DS不顺眼，那你可以换个ES也是一样的，至于ES（Extra  Segment）段寄存器的话，自然，是一个附加段寄存器，如果再说得过分点，就当它是个扩展吧，当你发现，你几个段寄存器不够用的时候，你可以考虑使用ES段寄存器，在使用方式上，则和其他的段寄存器没什么区别  。</p><p>下面看一个介绍使用DS寄存器的Demo：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">   </span><br><span class="line">START:</span><br><span class="line"></span><br><span class="line">    MOV AX,<span class="number">1000</span>H</span><br><span class="line">    MOV DS,AX</span><br><span class="line">    MOV AL,<span class="number">1</span></span><br><span class="line">    MOV BX,<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    MOV CX,<span class="number">5</span>;设计一个循环，让其循环 <span class="number">5</span> 次</span><br><span class="line">    s: MOV [BX],AL;这里 [BX] 并没有指定段地址哦</span><br><span class="line">       INC AL</span><br><span class="line">       INC BX</span><br><span class="line">       LOOP s            </span><br><span class="line">    </span><br><span class="line">    MOV AH,<span class="number">4</span>CH</span><br><span class="line">    INT <span class="number">21</span>H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><p>上面的代码所做的事情，就是循环将1，2，3，4，5写入到地址1000H：0000H ，1000H：0001H，1000H：0002H，1000H：0003H，1000H：0004H  中，</p><p>语句的执行过程如下：</p><p>首先我们来看尚未执行上述任何指令时栈中的数据情况：<br><img src="/images/2019/11/16/01c02080-07cd-11ea-9cf6-fb9e5c359a2c.png" alt="image.png"></p><p>而当循环执行完成以后，我们再来看内存  1000H：0000H 处的值：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012635.png" alt><br>在这里，我们可以看到确实达到了我们预期的效果，但是大家注意看代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s: MOV [BX],AL;这里 [BX] 并没有指定段地址哦</span><br><span class="line">    INC AL</span><br><span class="line">   INC BX</span><br><span class="line">   LOOP s</span><br></pre></td></tr></table></figure></p><p>这里可以看到，我们在[BX]  中并没有给其指定段地址，而只有一个偏移地址，但是根据我们一开始的介绍，必须要有段地址和偏移地址才能够定位内存单元，莫非这里出问题了？其实不是的，因为我们在最前面定义了段地址DS为1000H，当我们定义好段地址后，每一次CPU执行到[BX]时，便会自动或者说是默认的从  DS中取值，并且将取得的值作为段地址，因此，当[BX]为0001H时，CPU会从DS中取得一个1000H，由这两个一合成即可以得到正确的物理地址1000H：0000H 。</p><p>最后还提醒一点，那就是8086CPU不支持直接将一个数据送入段寄存器中，也就是下面的做法是错误的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV DS,<span class="number">1000</span>H</span><br></pre></td></tr></table></figure><h5 id="标志寄存器（FLAG）"><a href="#标志寄存器（FLAG）" class="headerlink" title="标志寄存器（FLAG）:"></a>标志寄存器（FLAG）:</h5><p>前面呢，已经介绍了8086CPU 14个寄存器中的13个了，下面我们将介绍最后一个寄存器也就是FLAG寄存器，FLAG寄存器之所以放到最后一个介绍，是因为其和其他的一些寄存器不同，像AX，BX，CX，DX这些寄存器来说，它们都是用来存放数据的，当然FLAG中存放的也是数据啦，呵呵，不过，AX，BX 这些寄存器中的数据是作为一个整体使用的，最多也就分成一个AL和AH使用而已，但是在FLAG中，数据是按位起作用的，也就是说，FLAG中的每一个位都表示不同的状态，由于一个位也就能表示0和1，自然，FLAG中的每一个位就是用来描述状态的，而且FLAG寄存器中存储的信息通常又被称作程序状态字（PSW）。下面我给出一幅  FLAG  寄存器中各个位的示意图：</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012657.png" alt><br>从上面这幅图中可以看出，FLAG的第0个位表示的是CF，第2个位表示的是PF，与此类推 . . . . </p><p>首先，我们来看一个列表：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012722.png" alt></p><p>上面的这个表怎么看呢？我们通过看下面一幅截图就知道了 。<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191116012745.png" alt></p><p>从上面的标记中可以看出，从左到右依次代表OF，DF，SF，ZF，PF，CF标志位的值，再通过与上面的表格相对照可以知道：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OF = <span class="number">0</span> ；</span><br><span class="line">DF = <span class="number">0</span> ；</span><br><span class="line">SF = <span class="number">0</span> ；</span><br><span class="line">ZF = <span class="number">0</span> ；</span><br><span class="line">PF = <span class="number">0</span> ；</span><br><span class="line">CF = <span class="number">0</span> ；</span><br></pre></td></tr></table></figure><p>至于为什么我们在Debug模式下，使用R命令时，只会列出这几个标志位，我菜的话是因为相对来说，列出的这几个标志位更为常用，其他的几个标志位并不经常使用的缘故吧 。下面我们就按不同的位来分别介绍这些位所描述的状态，以及它们代表的意义：</p><p>CF（Carry  FLag）—-进位标志（第 0 位）：<br>CF:进位标志是用来反映计算时是否产生了由低位向高位的进位，或者产生了从高位到低位的借位 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(运算过程中产生了进位或者借位)</span><br><span class="line">&#123;</span><br><span class="line">    CF  =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    CF  =  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PF（Parity  FLag）—-奇偶标志（第 2 位）：<br>PF:奇偶标志是用来记录相关指令执行后，其结果的所有的  Bit  位中  1  的个数是否为偶数 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(运算结果中 <span class="number">1</span> 的个数为偶数)</span><br><span class="line">&#123;</span><br><span class="line">     PF  =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     PF  =  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AF（Auxiliary  Carry  FLag）—-辅助进位标志（第 4 位）：<br>AF:用来辅助进位标志 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(字节操作中发生低半个字节向高半个字节借位或者进位  ||  字操作中发生低字节向高字节借位或者进位)</span><br><span class="line">&#123;</span><br><span class="line">     AF = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     AF = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZF（Zero  FLag）–—零标志（第 6 位）：</p><p>ZF:记录的是相关的指令执行完毕后，其执行的结果是否为  0 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(执行的结果  ==  <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">     ZF = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     ZF = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SF（Sign  FLag）—-符号标志（第 7 位）：</p><p>SF:符号标志，其记录相关指令执行完以后，其结果是否为负数 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(运算结果为负数)</span><br><span class="line">&#123;</span><br><span class="line">      SF  =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">      SF  =  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TF（Trap  FLag）—-追踪标志（第 8 位）：</p><p>TF:追踪标志，主要是用于调试时使用 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(TF  ==  <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">     CPU 进入单步方式;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IF（Interrupt-Enable  FLag）—-中断允许标志（第 9 位）：</p><p>IF:中断允许标志，其决定  CPU  是否能够响应外部可屏蔽中断请求（以后会做详细介绍） 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(IF  ==  <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">      CPU 能够响应外部的可屏蔽中断请求;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">      CPU 不能够响应外部的可屏蔽中断请求;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DF（Direction  FLag） - 方向标志（第 10 位）：</p><p>DF：    方向标志，其用于在串处理指令中，用来控制每次操作后  SI  和  DI  是自增还是自减 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(DF == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">      SI++;</span><br><span class="line">      DI++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">      SI--;</span><br><span class="line">      DI--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OF（OverFlow  FLag）—-溢出标志（第 11 位）：</p><p>OF:溢出标志，其通常记录了有符号数运算的结果是否发生了溢出 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(运算发生溢出)</span><br><span class="line">&#123;</span><br><span class="line">      OF  =  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">      OF  =  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上面呢，从最简单的开始，循序渐进的介绍了  8086  CPU  中的各个寄存器,同时也通过一些  Demo  来列举了各个寄存器的使用，由于写的比较基础，而且量也比较多，所以，造成博文过长了，读者需一定耐心才能看完，写本篇博文呢，并不是说将来要用汇编去开发个什么东东，实质上，笔者学习汇编的目的也不在此，只是因为先前在接触到底层的寄存器以及内存时，笔者总有一丝不爽的感觉，总是感觉不得要领，所以才会开始汇编的学习，此次推出本系列博文，本意也并不是说要学习汇编做开发，只是为了提升内功而已 。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h4&gt;&lt;p&gt;首先浅要介绍一下Intel CPU 的发展史吧：Intel CPU 系列，最初是4位微处理器4004，然后到到8位微处理器的8008，再到8微微处理器8080,以及稍后的16位微处理器8086，由8086开始，Intel进入现在所谓的  x86时代 。Intel 8086为16位CPU，而因为在8086之前的CPU都是8位CPU，这样也就造成了很多的外设也只支持8位，因此Intel紧接着就退出了8位的8088CPU，因此Intel 8088也就可以看做是8086的8位版本；如果是但从汇编语言的角度上来说，8086和8088是没有区别的，即8086上跑的程序可以不加修改的移植到 8088，8088上跑的程序也可以不加修改的移植到8086上，当然，还是有些特殊的地方是不同的，而这些基本上在这里可以忽略掉，在8088CPU 之后，Intel又推出了80186,80286，这两款CPU均是16位CPU，而对于80186来说，其与8086的区别可以简单的看做是80186多了几条指令而已，而80286则不同，80286的地址总线数目有了变化，在 8086, 8088, 80186上，CPU的地址总线都是20根，即可最大寻址达到1MB的寻址能力，而对于80286CPU来说，其地址总线数目达到了24根，从而最大寻址能力为16MB。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://tingyuxuan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://tingyuxuan.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>X86段机制页机制详解</title>
    <link href="http://tingyuxuan.com/2019/11/06/X86%E6%AE%B5%E6%9C%BA%E5%88%B6%E9%A1%B5%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://tingyuxuan.com/2019/11/06/X86段机制页机制详解/</id>
    <published>2019-11-05T21:24:29.000Z</published>
    <updated>2019-11-05T21:24:29.000Z</updated>
    
    <content type="html"><![CDATA[<center><font face="楷体" size="4">注：本文的主要内容来自对《深入分析linux内核源代码》的整理，linux内核版本为2.4.16</font></center><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>MOVE REG，ADDR ; 它把地址为ADDR（假设为10000）的内存单元的内容复制到REG中在8086 的实模式下，把某一段寄存器(基地址)左移4 位，然后与地址ADDR 相加后被直接送到内存总线上，这个相加后的地址(20位)就是内存单元的物理地址，而程序中的这个地址ADDR就叫逻辑地址(或叫虚拟地址)。<font face="楷体" size="4">在80386 的段机制中，逻辑地址由两部分组成，即段部分（选择符）及偏移部分。</font></p><a id="more"></a><p>段是形成逻辑地址到线性地址转换的基础。如果我们把段看成一个对象的话，那么对它的描述如下。<br>• 段的基地址(Base Address):在线性地址空间中段的起始地址。<br>• 段的界限(Limit):表示在逻辑地址中，段内可以使用的最大偏移量。<br>• 段的属性(Attribute):表示段的特性。例如，该段是否可被读出或写入，或者该段是否作为一个程序来执行，以及段的特权级等。</p><h4 id="逻辑地址、线性地址和物理地址"><a href="#逻辑地址、线性地址和物理地址" class="headerlink" title="逻辑地址、线性地址和物理地址"></a>逻辑地址、线性地址和物理地址</h4><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106053402.png" alt="qq"></p><center><font face="楷体" size="4">图1 MMU把逻辑地址转换为物理地址过程</font></center><h4 id="用户段描述符-User-Descriptor"><a href="#用户段描述符-User-Descriptor" class="headerlink" title="用户段描述符(User Descriptor)"></a>用户段描述符(User Descriptor)</h4><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106060132.png" alt></p><center><font face="楷体" size="4">图2 存取权字节的一般格式</font></center><p>一个段描述符指出了段的32 位基地址和20 位段界限（即段大小）。第6 个字节的G 位是粒度位，当G=0 时，段长表示段格式的字节长度，即一个段最长可达1M  字节。当G=1 时，段长表示段的以4K 字节为一页的页的数目，即一个段最长可达1M×4K=4G 字节。D 位表示缺省操作数的大小，如果D=0，操作数为16 位，如果D=1，操作数为32 位。    </p><p>第7 位P 位（Present） 是存在位，表示段描述符描述的这个段是否在内存中，如果在内存中。P=1；如果不在内存中，P=0。</p><p>DPL（Descriptor Privilege Level），就是描述符特权级，它占两位，其值为0～3，用来确定这个段的特权级即保护等级。0为内核级别，3为用户级别。</p><p>S 位（System）表示这个段是系统段还是用户段。如果S=0，则为系统段，如果S=1，则为用户程序的代码段、数据段或堆栈段。</p><p>类型占3 位，第3 位为E 位，表示段是否可执行。当E=0 时，为数据段描述符，这时的第2 位ED 表示地址增长方向。第1  位（W）是可写位。当段为代码段时，第3 位E=1，这时第2 位为一致位（C）。当C=1 时，如果当前特权级低于描述符特权级，并且当前特权级保持不变，那么代码段只能执行。所谓当前特权级CPL（Current  Privilege Level），就是当前正在执行的任务的特权级。第1 位为可读位R。</p><p>存取权字节的第0 位A 位是访问位，用于请求分段不分页的系统中，每当该段被访问时，将A 置1。对于分页系统，则A 被忽略未用。</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106062438.png" alt></p><center><font face="楷体" size="4">图3 数据段的存取字节</font></center><p><img src="/images/2019/11/06/bc583af0-001a-11ea-8860-b9b91b2a10f8.png" alt="image.png"></p><center><font face="楷体" size="4">图4 代码段的存取字节</font></center><h4 id="系统段描述符-Sys-Descriptor"><a href="#系统段描述符-Sys-Descriptor" class="headerlink" title="系统段描述符(Sys Descriptor)"></a>系统段描述符(Sys Descriptor)</h4><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106062329.png" alt></p><center><font face="楷体" size="4">图5 系统段描述符一般格式</font></center><p>系统段描述符的第5 个字节的第4 位为0，说明它是系统段描述符，类型占4 位，没有A 位。第6 个字节的第6 位为0，说明系统段的长度是字节粒度，所以，一个系统段的最大长度为1M字节。</p><p>系统段的类型为16 种，如图2.15 所示。在这16 种类型中，保留类型和有关286 的类型不予考虑。门也是一种描述符,有调用门、任务门、中断门和陷阱门4  种门描述符。</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106062556.png" alt></p><center><font face="楷体" size="4">图6 系统段的类型</font></center><h4 id="选择符、描述符表和描述符表寄存器"><a href="#选择符、描述符表和描述符表寄存器" class="headerlink" title="选择符、描述符表和描述符表寄存器"></a>选择符、描述符表和描述符表寄存器</h4><p>描述符表（即段表）定义了386 系统的所有段的情况。所有的描述符表本身都占据一个字节为8 的倍数的存储器空间，空间大小在8 个字节（至少含一个描述符）到64K 字节（至多含8K=8192）个描述符之间。</p><p>1.全局描述符表（GDT）<br>全局描述符表GDT（Global Descriptor Table），除了任务门，中断门和陷阱门描述符外，包含着系统中所有任务都共用的那些段的描述符。它的第一个8 字节位置没有使用。</p><p>2.中断描述符表（IDT）<br>中断描述符表IDT（Interrupt Descriptor Table），包含256 个门描述符。IDT 中只能包含任务门、中断门和陷阱门描述符，虽然IDT 表最长也可以为64K 字节，但只能存取2K字节以内的描述符，即256  个描述符，这个数字是为了和8086 保持兼容。</p><p>3.局部描述符表（LDT）</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106062802.png" alt></p><center><font face="楷体" size="4">图7 选择符表结构</font></center><p>局部描述符表LDT（Local Descriptor Table），包含了与一个给定任务有关的描述符，每个任务各自有一个的LDT。有了LDT，就可以使给定任务的代码、数据与别的任务相隔离。每一个任务的局部描述符表LDT  本身也用一个描述符来表示，称为LDT 描述符，它包含了有关局部描述符表的信息，被放在全局描述符表GDT 中，使用LDTR进行索引。</p><p>在实模式下，段寄存器存储的是真实的段基址，在保护模式下，16 位的段寄存器无法放下32 位的段基址，因此，它们被称为选择符，即段寄存器的作用是用来选择描述符。选择符的结构如图2.16  所示。</p><p>可以看出，选择符有3 个域：第15~3 位这13 位是索引域，表示的数据为0~8129，用于指向全局描述符表中相应的描述符。第2 位为选择域，如果TI=1，就从局部描述符表中选择相应的描述符，如果TI=0，就从全局描述符表中选择描述符。第1、0  位是特权级，表示选择符的特权级，被称为请求者特权级RPL（Requestor Privilege Level）。只有请求者特权级RPL  高于（数字低于）或等于相应的描述符特权级DPL，描述符才能被存取，这就可以实现一定程度的保护。</p><p>下面讲一下在没有分页操作时，寻址一个存储器操作数的步骤。<br>(1)在段选择符中装入16 位数，同时给出32 位地址偏移量（比如在ESI、EDI 中等）。<br>(2)先根据相应描述符表寄存器中的段地址（确定描述符表的地址）和段界限（确定描述符表的大小），根据段选择符的TI决定从哪种描述符表中取，再根据段选择符的索引找到相应段描述符的位置，比较RPL与DPL，若该段无问题，就取出相应的段描述符放入段描述符高速缓冲寄存器中。<br>(3)将段描述符中的32 位段基地址和放在ESI、EDI 等中的32 位有效地址相加，就形成了32 位物理地址。</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106062851.png" alt></p><center><font face="楷体" size="4">图8 寻址过程</font></center><h4 id="linux中的段机制"><a href="#linux中的段机制" class="headerlink" title="linux中的段机制"></a>linux中的段机制</h4><p>从2.2 版开始，Linux 让所有的进程（或叫任务）都使用相同的逻辑地址空间，因此就没有必要使用局部描述符表LDT。</p><p>Linux 在启动的过程中设置了段寄存器的值和全局描述符表GDT 的内容，段寄存器的定义在include/asm-i386/segment.h 中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_CS 0x10 <span class="comment">//内核代码段，index=2,TI=0,RPL=0 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_DS 0x18 <span class="comment">//内核数据段, index=3,TI=0,RPL=0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_CS   0x23 <span class="comment">//用户代码段, index=4,TI=0,RPL=3</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __USER_DS   0x2B <span class="comment">//用户数据段, index=5,TI=0,RPL=3</span></span></span><br></pre></td></tr></table></figure></p><p>从定义看出，没有定义堆栈段，实际上，Linux 内核不区分数据段和堆栈段，这也体现了Linux 内核尽量减少段的使用。因为没有使用LDT，因此，TI=0，并把这4 个段描述符都放在GDT中,  index 就是某个段描述符在GDT 表中的下标。内核代码段和数据段具有最高特权，因此其RPL为0，而用户代码段和数据段具有最低特权，因此其RPL 为3。</p><p>全局描述符表的定义在arch/i386/kernel/head.S 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ENTRY（gdt_table）</span><br><span class="line">.quad <span class="number">0x0000000000000000</span> <span class="comment">/* NULL descriptor */</span></span><br><span class="line">.quad <span class="number">0x0000000000000000</span> <span class="comment">/* not used */</span></span><br><span class="line">.quad <span class="number">0x00cf9a000000ffff</span> <span class="comment">/* 0x10 kernel 4GB code at 0x00000000 */</span></span><br><span class="line">.quad <span class="number">0x00cf92000000ffff</span> <span class="comment">/* 0x18 kernel 4GB data at 0x00000000 */</span></span><br><span class="line">.quad <span class="number">0x00cffa000000ffff</span> <span class="comment">/* 0x23 user 4GB code at 0x00000000 */</span></span><br><span class="line">.quad <span class="number">0x00cff2000000ffff</span> <span class="comment">/* 0x2b user 4GB data at 0x00000000 */</span></span><br><span class="line">.quad <span class="number">0x0000000000000000</span> <span class="comment">/* not used */</span></span><br><span class="line">.quad <span class="number">0x0000000000000000</span> <span class="comment">/* not used */</span></span><br></pre></td></tr></table></figure><p>从代码可以看出，GDT 放在数组变量gdt_table 中。按Intel 规定，GDT 中的第一项为空，这是为了防止加电后段寄存器未经初始化就进入保护模式而使用GDT 的。第二项也没用。从下标2～5  共4 项对应于前面的4 种段描述符值。对照图2.10，从描述符的数值可以得出：</p><p>• 段的基地址全部为0x00000000；<br>• 段的上限全部为0xffff；<br>• 段的粒度G 为1，即段长单位为4KB；<br>• 段的D 位为1，即对这4 个段的访问都为32 位指令；<br>• 段的P 位为1，即4 个段都在内存。</p><p>由此可以得出，每个段的逻辑地址空间范围为0～4GB。每个段的基地址为0，因此，逻辑地址到线性地址映射保持不变，也就是说，偏移量就是线性地址，我们以后所提到的逻辑地址（或虚拟地址）和线性地址指的也就是同一地址。看来，Linux  巧妙地把段机制给绕过去了，它只把段分为两种：用户态（RPL＝3）的段和内核态（RPL=0）的段，而完全利用了分页机制。</p><p>按Intel 的规定，每个进程有一个任务状态段（TSS）和局部描述符表LDT，但Linux 也没有完全遵循Intel 的设计思路。如前所述，Linux 的进程没有使用LDT，而对TSS 的使用也非常有限，每个CPU  仅使用一个TSS。TSS 有它自己 8 字节的任务段描述符（Task State Segment Descriptor ，简称TSSD）。这个描述符包括指向TSS 起始地址的32 位基地址域，20 位界限域，界限域值不能小于十进制104（由TSS  段的最小长度决定）。TSS 描述符存放在GDT 中，它是GDT 中的一个表项，由中断描述符表（IDT）中的任务门（存放TSS段的选择符）装入TR来进行索引。</p><h4 id="页目录项、页表项、页面项"><a href="#页目录项、页表项、页面项" class="headerlink" title="页目录项、页表项、页面项"></a>页目录项、页表项、页面项</h4><p>80386 使用4K 字节大小的页。每一页都有4K 字节长，并在4K 字节的边界上对齐，即每一页的起始地址都能被4K 整除。因此，80386 把4G 字节的线性地址空间，划分为1G 个页面，每页有4K  字节大小。分页机制通过把线性地址空间中的页，重新定位到物理地址空间来进行管理，因为每个页面的整个4K 字节作为一个单位进行映射，并且每个页面都对齐4K 字节的边界，因此，线性地址的低12 位经过分页机制直接地作为物理地址的低12 位使用。</p><p>页目录表，存储在一个4K 字节的页面中，最多可包含1024  个页目录项，每个页目录项为4 个字节，结构如图9所示。</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106063019.png" alt></p><center><font face="楷体" size="4">图9 页目录中的页目录项</font></center><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106063116.png" alt></p><center><font face="楷体" size="4">图10 由U/S和R/W提供的保护</font></center><p>• 第31~12位是20位页表地址，由于页表地址的低12位总为0，所以用高20 位指出32位页表地址就可以了。<br>• 第0位是存在位，如果P=1，表示页表地址指向的该页在内存中，如果P=0，表示不在内存中。<br>• 第1位是读/写位，第2 位是用户/管理员位，这两位为页目录项提供硬件保护。当特权级为3  的进程要想访问页面时，需要通过页保护检查，而特权级为0 的进程就可以绕过页保护，如图2.23 所示。</p><p>• 第3位是PWT（Page Write-Through）位，表示是否采用写透方式，写透方式就是既写内存（RAM）也写高速缓存,该位为1  表示采用写透方式。<br>• 第4位是PCD（Page Cache Disable）位，表示是否启用高速缓存，该位为1 表示启用高速缓存。<br>• 第5位是访问位，当对页目录项进行访问时，A位=1。<br>• 第7位是Page Size 标志，只适用于页目录项。如果置为1，页目录项指的是4MB 的页面，即扩展分页。</p><p>80386的每个页目录项指向一个页表，存储在一个4K字节的页面中，页表最多含有1024个页面项，每项4  个字节，包含页面的起始地址和有关该页面的信息。页面的起始地址也是4K的整数倍，所以页面的低12位也留作它用，如图2.24所示。</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106063246.png" alt></p><center><font face="楷体" size="4">图11 页表中的页面项</font></center><p>第31～12位是20位物理页面地址，除第6位外第0～5位及9～11位的用途和页目录项一样，第6位是页面项独有的，当对涉及的页面进行写操作时，D位被置1。</p><p>4GB的存储器只有一个页目录，它最多有1024个页目录项，每个页目录项又含有1024个页面项，因此，存储器一共可以分成1024×1024=1M个页面。由于每个页面为4K个字节，所以，存储器的大小正好最多为4GB。</p><p>当访问一个操作单元时，如何由分段结构确定的32位线性地址通过分页操作转化成32位物理地址呢？</p><p>第一步，CR3包含着页目录的起始地址，用32位线性地址的最高10位A31~A22作为页目录表的页目录项的索引，将它乘以4，与CR3 中的页目录表的起始地址相加，形成相应页目录项的地址。</p><p>第二步，从指定的地址中取出32位页目录项，它的低12位为0，这32位是页表的起始地址。用32位线性地址中的A21~A12位作为页表中的页表项的索引，将它乘以4，与页表的起始地址相加，形成相应页表项的地址。</p><p>第三步，从指定地址中取出32位页表项，它的低12位为0，这32位是页面地址，将A11~A0作为相对于页面地址的偏移量，与32位页面地址相加，形成32位物理地址。</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106070415.png" alt></p><center><font face="楷体" size="4">图12 两级页表结构</font></center><h4 id="linux-中的分页机制"><a href="#linux-中的分页机制" class="headerlink" title="linux 中的分页机制"></a>linux 中的分页机制</h4><p>Linux 的分段机制使得所有的进程都使用相同的段寄存器值，这就使得内存管理变得简单，也就是说，所有的进程都使用同样的线性地址空间（0～4GB）。Linux  采用三级分页模式而不是两级。如图2.28 所示为三级分页模式，为此，Linux定义了3 种类型的表。</p><p>• 总目录PGD（Page Global Directory）<br>• 中间目录PMD（Page Middle Derectory）<br>• 页表PT（Page Table）</p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106063456.png" alt></p><center><font face="楷体" size="4">图13 Linux三级分页</font></center>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font face=&quot;楷体&quot; size=&quot;4&quot;&gt;注：本文的主要内容来自对《深入分析linux内核源代码》的整理，linux内核版本为2.4.16&lt;/font&gt;&lt;/center&gt;


&lt;h4 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h4&gt;&lt;p&gt;MOVE REG，ADDR ; 它把地址为ADDR（假设为10000）的内存单元的内容复制到REG中在8086 的实模式下，把某一段寄存器(基地址)左移4 位，然后与地址ADDR 相加后被直接送到内存总线上，这个相加后的地址(20位)就是内存单元的物理地址，而程序中的这个地址ADDR就叫逻辑地址(或叫虚拟地址)。&lt;font face=&quot;楷体&quot; size=&quot;4&quot;&gt;在80386 的段机制中，逻辑地址由两部分组成，即段部分（选择符）及偏移部分。&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="http://tingyuxuan.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://tingyuxuan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存的作用</title>
    <link href="http://tingyuxuan.com/2019/11/05/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://tingyuxuan.com/2019/11/05/虚拟内存的作用/</id>
    <published>2019-11-05T05:35:23.000Z</published>
    <updated>2019-11-05T05:35:23.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h4><p>虚拟地址的整个想法是这样的：把程序给出的地址看做是一种虚拟地址（Virtual Address），然后通过某些映射的方法，将这个虚拟地址转换成实际的物理地址。这样，只要我们能够妥善地控制这个虚拟地址到物理地址的映射过程，就可以保证程序每次运行时都可以使用相同的地址。<br><a id="more"></a></p><p>例如，上面代码中变量 a 的地址是 0X402000，第一次运行时它对应的物理内存地址可能是 0X12ED90AA，第二次运行时可能又对应 0XED90，而我们的程序不需要关心这些，这些繁杂的内存管理工作交给操作系统处理即可。</p><p>让我们回到程序的运行本质上来。用户程序在运行时不希望介入到这些复杂的内存管理过程中，作为普通的程序，它需要的是一个简单的执行环境，有自己的内存，有自己的CPU，好像整个程序占有整个计算机而不用关心其他的程序。</p><p>除了在编程时可以使用固定的内存地址，给程序员带来方便外，使用虚拟地址还能够使不同程序的地址空间相互隔离，提高内存使用效率。</p><h4 id="使不同程序的地址空间相互隔离"><a href="#使不同程序的地址空间相互隔离" class="headerlink" title="使不同程序的地址空间相互隔离"></a>使不同程序的地址空间相互隔离</h4><p>如果所有程序都直接使用物理内存，那么程序所使用的地址空间不是相互隔离的。恶意程序可以很容易改写其他程序的内存数据，以达到破坏的目的；有些非恶意、但是有 Bug 的程序也可能会不小心修改其他程序的数据，导致其他程序崩溃。</p><p>这对于需要安全稳定的计算机环境的用户来说是不能容忍的，用户希望他在使用计算机的时候，其中一个任务失败了，至少不会影响其他任务。</p><p>使用了虚拟地址后，程序A和程序B虽然都可以访问同一个地址，但它们对应的物理地址是不同的，无论如何操作，都不会修改对方的内存。</p><h4 id="提高内存使用效率"><a href="#提高内存使用效率" class="headerlink" title="提高内存使用效率"></a>提高内存使用效率</h4><p>使用虚拟地址后，操作系统会更多地介入到内存管理工作中，这使得控制内存权限成为可能。例如，我们希望保存数据的内存没有执行权限，保存代码的内存没有修改权限，操作系统占用的内存普通程序没有读取权限等。</p><p>另外，当物理内存不足时，操作系统能够更加灵活地控制换入换出的粒度，磁盘 I/O 是非常耗时的工作，这能够从很大程度上提高程序性能。</p><h4 id="中间层思想"><a href="#中间层思想" class="headerlink" title="中间层思想"></a>中间层思想</h4><p>在计算机中，为了让操作更加直观、易于理解、增强用户体验，开发者经常会使用一件法宝——增加中间层，即使用一种间接的方式来屏蔽复杂的底层细节，只给用户提供简单的接口。虚拟地址是使用中间层的一个典型例子。</p><p>实际上，计算机的整个发展过程就是不断引入新的中间层：<br>•计算机的早期，程序都是直接运行在硬件之上，自己负责硬件的管理工作；程序员也使用二进制进行编程，需要处理各种边界条件和安全问题。<br>•后来人们不能忍受了，于是开发出操作系统，让它来管理各种硬件，同时发明了汇编语言，减轻程序员的负担。<br>•随着软件规模的不断增大，使用汇编语言编程开始变得捉襟见肘，不仅学习成本高，开发效率也很低，于是C语言诞生了。C语言编译器先将C代码翻译为汇编代码，再由汇编器将汇编代码翻译成机器指令。<br>•随着计算机的发展，硬件越来越强大，软件越来越复杂，人们又不满足于使用C语言了，于是 C++、Java、C#、PHP 等现代化的编程语言诞生了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;虚拟地址&quot;&gt;&lt;a href=&quot;#虚拟地址&quot; class=&quot;headerlink&quot; title=&quot;虚拟地址&quot;&gt;&lt;/a&gt;虚拟地址&lt;/h4&gt;&lt;p&gt;虚拟地址的整个想法是这样的：把程序给出的地址看做是一种虚拟地址（Virtual Address），然后通过某些映射的方法，将这个虚拟地址转换成实际的物理地址。这样，只要我们能够妥善地控制这个虚拟地址到物理地址的映射过程，就可以保证程序每次运行时都可以使用相同的地址。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://tingyuxuan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://tingyuxuan.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>程序内存区域分配的五个段</title>
    <link href="http://tingyuxuan.com/2019/11/04/%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%86%E9%85%8D%E7%9A%84%E4%BA%94%E4%B8%AA%E6%AE%B5/"/>
    <id>http://tingyuxuan.com/2019/11/04/程序内存区域分配的五个段/</id>
    <published>2019-11-03T23:59:21.000Z</published>
    <updated>2019-11-03T23:59:21.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h4><p>在学习之前我们先看看ELF文件。<br><a id="more"></a></p><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106075719.png" alt></p><center><font face="楷体" size="4">图1 ELF文件格式图</font></center><h4 id="ELF分为三种类型"><a href="#ELF分为三种类型" class="headerlink" title="ELF分为三种类型"></a>ELF分为三种类型</h4><p>.o可重定位文件(relocalble file)，可执行文件以及共享库(shared library)，三种格式基本上从结构上是一样的，只是具体到每一个结构不同。下面我们就从整体上看看这3种格式从文件内容上存储的方式，spec上有张图是比较经典的：如上图：其实从文件存储的格式来说，上面的两种view实际上是一样的，Segment实际上就是由section组成的，将相应的一些section映射到一起就叫segment了,就是说segment是由0个或多个section组成的，实际上本质都是section。在这里我们首先来仔细了解一下section和segment的概念：</p><p>section就是相同或者相似信息的集合，比如我们比较熟悉的.text.data.bss section，.text是可执行指令的集合，.data是初始化后数据的集合，.bss是未初始化数据的集合。实际上我们也可以将一个程序的所有内容都放在一起，就像dos一样，但是将可执行程序分成多个section是很有好处的，比如说我们可以将.text section放在memory的只读空间内，将可变的.data section放在memory的可写空间内。</p><p>从可执行文件的角度来讲，如果一个数据未被初始化那就不需要为其分配空间，所以.data和.bss一个重要的区别就是.bss并不占用可执行文件的大小，它只是记载需要多少空间来存储这些未初始化数据，而不分配实际的空间。</p><p>可以通过命令 $ readelf -l a.out 查看文件的格式和组成。</p><h4 id="不同视角下的程序"><a href="#不同视角下的程序" class="headerlink" title="不同视角下的程序"></a>不同视角下的程序</h4><p>站在汇编语言的角度，一个程序分为：<br>数据段 — DS<br>堆栈段 — SS<br>代码段 — CS<br>扩展段 – ES</p><p>站在高级语言的角度，根据APUE，一个程序分为如下段：<br>text – 代码段<br>data (initialized) – 初始化数据段<br>bss – 未初始化数据段<br>stack – 栈区<br>heap – 堆区</p><p>1.一般情况下，一个可执行二进制程序(更确切的说，在Linux操作系统下为一个进程单元，在UC/OSII中被称为任务)在存储(没有调入到内存运行)时拥有3个部分，分别是代码段(text)、数据段(data)和BSS段。这3个部分一起组成了该可执行程序的文件。</p><center><font face="楷体" size="4">可执行二进制程序 = 代码段(text)＋数据段(data)+BSS段</font></center><p>2.而当程序被加载到内存单元时，则需要另外两个域：堆域和栈域。图1-1所示为可执行代码存储态和运行态的结构对照图。一个正在运行的C程序占用的内存区域分为代码段、初始化数据段、未初始化数据段(BSS)、堆、栈5个部分。</p><center><font face="楷体" size="4">正在运行的C程序 = 代码段+初始化数据段(data)+未初始化数据段(BSS)+堆+栈</font></center><p>3.在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显示地申请和释放空间。</p><p>4.动态分配与静态分配，二者最大的区别在于:</p><font face="楷体" size="4" color="blue">1.直到Run-Time的时候，执行动态分配，而在compile-time的时候，就已经决定好了分配多少Text+Data+BSS+Stack。</font><font face="楷体" size="4" color="red">2.通过malloc()动态分配的内存，需要程序员手工调用free()释放内存，否则容易导致内存泄露，而静态分配的内存则在进程执行结束后系统释放(Text, Data), 但Stack段中的数据很短暂，函数退出立即被销毁。</font><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106081413.png" alt></p><center><font face="楷体" size="4">图2 执行文件与地址空间</font></center><p>图2 从可执行文件a.out的角度来讲，如果一个数据未被初始化那就不需要为其分配空间，所以.data和.bss一个重要的区别就是.bss并不占用可执行文件的大小，它只是记载需要多少空间来存储这些未初始化数据，而不分配实际的空间。</p><h4 id="不同数据段的详解"><a href="#不同数据段的详解" class="headerlink" title="不同数据段的详解"></a>不同数据段的详解</h4><p>代码段 —text（code segment/text segment）<br>text段在内存中被映射为<strong>只读</strong>，但.data和.bss是<strong>可写</strong>的。<br>text段是程序代码段，在AT91库中是表示程序段的大小，它是由编译器在编译连接时自动计算的，当你在链接定位文件中将该符号放置在代码段后，那么该符号表示的值就是代码段大小，编译连接时，该符号所代表的值会自动代入到源程序中。</p><p>数据段 — data<br>data包含静态初始化的数据，所以有初值的全局变量和static变量在data区。段的起始位置也是由连接定位文件所确定，大小在编译连接时自动分配，它和你的程序大小没有关系，但和程序使用到的全局变量，常量数量相关。数据段属于静态内存分配。 </p><p>bss段—bss<br>bss是英文Block Started by Symbol的简称，通常是指用来存放程序中未初始化的全局变量的一块内存区域，在程序载入时由内核清0。BSS段属于静态内存分配。它的初始值也是由用户自己定义的连接定位文件所确定，用户应该将它定义在可读写的RAM区内，源程序中使用malloc分配的内存就是这一块，它不是根据data大小确定，主要由程序中同时分配内存最大值所确定，不过如果超出了范围，也就是分配失败，可以等空间释放之后再分配。BSS段属于静态内存分配。</p><p>stack：<br>栈(stack)保存函数的局部变量（但不包括static声明的变量， static 意味着 在数据段中 存放变量），参数以及返回值。是一种“后进先出”（Last In First Out，LIFO）的数据结构，这意味着最后放到栈上的数据，将会是第一个从栈上移走的数据。对于哪些暂时存贮的信息，和不需要长时间保存的信息来说，LIFO这种数据结构非常理想。在调用函数或过程后，系统通常会清除栈上保存的局部变量、函数调用信息及其它的信息。栈另外一个重要的特征是，它的地址空间“向下减少”，即当栈上保存的数据越多，栈的地址就越低。栈（stack）的顶部在可读写的RAM区的最后。</p><p>heap:<br>堆(heap)保存函数内部动态分配内存，是另外一种用来保存程序信息的数据结构，更准确的说是保存程序的动态变量。堆是“先进先出”（First In first Out，FIFO）数据结构。它只允许在堆的一端插入数据，在另一端移走数据。堆的地址空间“向上增加”，即当堆上保存的数据越多，堆的地址就越高。</p><center><font face="楷体" size="4">表1 五段总结</font></center><div class="table-container"><table><thead><tr><th>名称</th><th>内容</th></tr></thead><tbody><tr><td>代码段</td><td>可执行代码，字符串常量</td></tr><tr><td>数据段</td><td>已初始化全局变量，已初始化、局部静态变量、常量数据</td></tr><tr><td>BSS段</td><td>未初始化全局变量，未初始化全局静态变量</td></tr><tr><td>栈段</td><td>局部变量、函数参数</td></tr><tr><td>堆段</td><td>动态内存分配</td></tr></tbody></table></div><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106082822.png" alt></p><center><font face="楷体" size="4">图3 APUE中的一个典型C内存空间分布图</font></center><p>所以可以知道：传入的参数,局部变量,都是在栈顶分布,随着子函数的增多而向下增长.<br>函数的调用地址(函数运行代码),全局变量,静态变量都是在分配内存的低部存在,而malloc分配的堆则存在于这些内存之上,并向上生长.</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> g_A = <span class="number">10</span>;  <span class="comment">//代码段</span></span><br><span class="line"><span class="keyword">int</span> g_B = <span class="number">20</span>;        <span class="comment">//数据段</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_C = <span class="number">30</span>; <span class="comment">//数据段</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_D;      <span class="comment">//BSS段</span></span><br><span class="line"><span class="keyword">int</span> g_E;             <span class="comment">//BSS段</span></span><br><span class="line"><span class="keyword">char</span> *p1;            <span class="comment">//BSS段</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> local_A;            <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">int</span> local_B;            <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> local_C = <span class="number">0</span>; <span class="comment">//数据段</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> local_D;     <span class="comment">//数据段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">"123456"</span>; <span class="comment">//123456在代码段，p3在栈上</span></span><br><span class="line"></span><br><span class="line">    p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); <span class="comment">//堆，分配得来得10字节的区域在堆区</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>); <span class="comment">//123456&#123;post.content&#125;放在常量区，编译器可能会将它与p3所指向 的"123456"优化成一块</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hight address\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------------栈--------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈, 局部变量, local_A, addr:0x%08x\n"</span>, &amp;local_A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈, 局部变量,(后进栈地址相对local_A低)  local_B, addr:0x%08x\n"</span>, &amp;local_B);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------------堆--------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆, malloc分配内存,  p1,  addr:0x%08x\n"</span>, p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------BSS段------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSS段, 全局变量,       未初始化    g_E,     addr:0x%08x\n"</span>, &amp;g_E, g_E);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSS段, 静态全局变量,   未初始化,   g_D,     addr:0x%08x\n"</span>, &amp;g_D);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSS段, 静态局部变量,   初始化,     local_C, addr:0x%08x\n"</span>, &amp;local_C);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSS段, 静态局部变量,   未初始化,   local_D, addr:0x%08x\n"</span>, &amp;local_D);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------数据段------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数据段,全局变量,       初始化      g_B,     addr:0x%08x\n"</span>, &amp;g_B);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数据段,静态全局变量,   初始化,     g_C,     addr:0x%08x\n"</span>, &amp;g_C);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------代码段------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"代码段,全局初始化变量, 只读const,  g_A,     addr:0x%08x\n\n"</span>, &amp;g_A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"low address\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hight address</span><br><span class="line"></span><br><span class="line">-------------栈--------------</span><br><span class="line">栈,    局部变量,                             local_A, addr:<span class="number">0xffa70c1c</span></span><br><span class="line">栈,    局部变量,(后进栈地址相对local_A低)     local_B, addr:<span class="number">0xffa70c18</span></span><br><span class="line">-------------堆--------------</span><br><span class="line">堆,    <span class="built_in">malloc</span>分配内存,             p1,      addr:<span class="number">0x087fe008</span></span><br><span class="line">------------BSS段------------</span><br><span class="line">BSS段, 全局变量,       未初始化    g_E,     addr:<span class="number">0x08049a64</span></span><br><span class="line">BSS段, 静态全局变量,   未初始化,   g_D,     addr:<span class="number">0x08049a5c</span></span><br><span class="line">BSS段, 静态局部变量,   初始化,     local_C, addr:<span class="number">0x08049a58</span></span><br><span class="line">BSS段, 静态局部变量,   未初始化,   local_D, addr:<span class="number">0x08049a54</span></span><br><span class="line">-----------数据段------------</span><br><span class="line">数据段,全局变量,       初始化      g_B,     addr:<span class="number">0x08049a44</span></span><br><span class="line">数据段,静态全局变量,   初始化,     g_C,     addr:<span class="number">0x08049a48</span></span><br><span class="line">-----------代码段------------</span><br><span class="line">代码段,全局初始化变量, 只读<span class="keyword">const</span>,  g_A,     addr:<span class="number">0x08048620</span></span><br><span class="line"></span><br><span class="line">low address</span><br></pre></td></tr></table></figure></p><p><strong>++注意：++</strong><br>编译时需要-g选项，这样才可以看elf信息；<br>readelf -a a.out<br>查看这个执行文件的elf信息，摘录部分如下：重点注意其中data段，text段还要有bss段的地址，然后比较这个地址和上面的运行结果，是否是在elf文件的各个段的地址之内。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>            <span class="number">00000000</span> <span class="number">000000</span> <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .interp           PROGBITS        <span class="number">08048114</span> <span class="number">000114</span> <span class="number">000013</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .note.ABI-tag     NOTE            <span class="number">08048128</span> <span class="number">000128</span> <span class="number">000020</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">3</span>] .gnu.hash         GNU_HASH        <span class="number">08048148</span> <span class="number">000148</span> <span class="number">000020</span> <span class="number">04</span>   A  <span class="number">4</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .dynsym           DYNSYM          <span class="number">08048168</span> <span class="number">000168</span> <span class="number">000070</span> <span class="number">10</span>   A  <span class="number">5</span>   <span class="number">1</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .dynstr           STRTAB          <span class="number">080481</span>d8 <span class="number">0001</span>d8 <span class="number">000058</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">6</span>] .gnu.version      VERSYM          <span class="number">08048230</span> <span class="number">000230</span> <span class="number">00000</span>e <span class="number">02</span>   A  <span class="number">4</span>   <span class="number">0</span>  <span class="number">2</span></span><br><span class="line">  [ <span class="number">7</span>] .gnu.version_r    VERNEED         <span class="number">08048240</span> <span class="number">000240</span> <span class="number">000020</span> <span class="number">00</span>   A  <span class="number">5</span>   <span class="number">1</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">8</span>] .rel.dyn          REL             <span class="number">08048260</span> <span class="number">000260</span> <span class="number">000008</span> <span class="number">08</span>   A  <span class="number">4</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">9</span>] .rel.plt          REL             <span class="number">08048268</span> <span class="number">000268</span> <span class="number">000028</span> <span class="number">08</span>   A  <span class="number">4</span>  <span class="number">11</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">10</span>] .init             PROGBITS        <span class="number">08048290</span> <span class="number">000290</span> <span class="number">000017</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">11</span>] .plt              PROGBITS        <span class="number">080482</span>a8 <span class="number">0002</span>a8 <span class="number">000060</span> <span class="number">04</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">12</span>] .text             PROGBITS        <span class="number">08048310</span> <span class="number">000310</span> <span class="number">0002e8</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  [<span class="number">13</span>] .fini             PROGBITS        <span class="number">080485f</span>8 <span class="number">0005f</span>8 <span class="number">00001</span>c <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">14</span>] .rodata           PROGBITS        <span class="number">08048614</span> <span class="number">000614</span> <span class="number">000326</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">15</span>] .eh_frame         PROGBITS        <span class="number">0804893</span>c <span class="number">00093</span>c <span class="number">000004</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">16</span>] .ctors            PROGBITS        <span class="number">08049940</span> <span class="number">000940</span> <span class="number">000008</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">17</span>] .dtors            PROGBITS        <span class="number">08049948</span> <span class="number">000948</span> <span class="number">000008</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">18</span>] .jcr              PROGBITS        <span class="number">08049950</span> <span class="number">000950</span> <span class="number">000004</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">19</span>] .dynamic          DYNAMIC         <span class="number">08049954</span> <span class="number">000954</span> <span class="number">0000</span>c8 <span class="number">08</span>  WA  <span class="number">5</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">20</span>] .got              PROGBITS        <span class="number">08049</span>a1c <span class="number">000</span>a1c <span class="number">000004</span> <span class="number">04</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">21</span>] .got.plt          PROGBITS        <span class="number">08049</span>a20 <span class="number">000</span>a20 <span class="number">000020</span> <span class="number">04</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">22</span>] .data             PROGBITS        <span class="number">08049</span>a40 <span class="number">000</span>a40 <span class="number">00000</span>c <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">23</span>] .bss              NOBITS          <span class="number">08049</span>a4c <span class="number">000</span>a4c <span class="number">00001</span>c <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">24</span>] .comment          PROGBITS        <span class="number">00000000</span> <span class="number">000</span>a4c <span class="number">000114</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">25</span>] .debug_aranges    PROGBITS        <span class="number">00000000</span> <span class="number">000b</span>60 <span class="number">000020</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">26</span>] .debug_pubnames   PROGBITS        <span class="number">00000000</span> <span class="number">000b</span>80 <span class="number">00003</span>a <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">27</span>] .debug_info       PROGBITS        <span class="number">00000000</span> <span class="number">000b</span>ba <span class="number">0001f</span>4 <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">28</span>] .debug_abbrev     PROGBITS        <span class="number">00000000</span> <span class="number">000</span>dae <span class="number">00006f</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">29</span>] .debug_line       PROGBITS        <span class="number">00000000</span> <span class="number">000e1</span>d <span class="number">000058</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">30</span>] .debug_frame      PROGBITS        <span class="number">00000000</span> <span class="number">000e78</span> <span class="number">00003</span>c <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">31</span>] .debug_str        PROGBITS        <span class="number">00000000</span> <span class="number">000</span>eb4 <span class="number">00000</span>d <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">32</span>] .debug_loc        PROGBITS        <span class="number">00000000</span> <span class="number">000</span>ec1 <span class="number">000043</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">33</span>] .shstrtab         STRTAB          <span class="number">00000000</span> <span class="number">000f</span>04 <span class="number">000143</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">34</span>] .symtab           SYMTAB          <span class="number">00000000</span> <span class="number">0015e8</span> <span class="number">000560</span> <span class="number">10</span>     <span class="number">35</span>  <span class="number">60</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">35</span>] .strtab           STRTAB          <span class="number">00000000</span> <span class="number">001b</span>48 <span class="number">0002</span>ad <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure></p><p>★注意静态变量初始化为零和全局静态变量初始化为零的情况，都是存储在bss段★<br>从上面的elf文件可以看出，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">23</span>] .bss  NOBITS    <span class="number">08049</span>a4c <span class="number">000</span>a4c <span class="number">00001</span>c <span class="number">00</span>    WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">[<span class="number">22</span>] .data PROGBITS   <span class="number">08049</span>a40000a40 <span class="number">00000</span>c <span class="number">00</span>     WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">[<span class="number">12</span>] .text PROGBITS   <span class="number">08048310000310</span> <span class="number">0002e8</span> <span class="number">00</span>     AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">16</span></span><br><span class="line">但是在结果中显示：BSS段, 静态局部变量,初始化,  local_C, addr:<span class="number">0x08049a58</span></span><br></pre></td></tr></table></figure><br>0x08049a58 大于0x08049a4c 属于bss段是初始化的静态局部变量但是却属于bss段，为什么？<br>原因是：local_C是局部静态变量但是却初始化为零。这和没有初始化，默认是零的情况一样，都存储在bss段，如果初始化为其他的值，那么local_C这个变量就会存储在data段。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>可执行文件大小由什么决定？可执行文件在存储时分为代码段、数据段和BSS段三个部分。<br>程序1:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ar[<span class="number">30000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序2:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ar[<span class="number">300000</span>] =  &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现程序2编译之后所得的.exe文件比程序1的要大得多。当下甚为不解，于是手工编译了一下，并使用了/FAs编译选项来查看了一下其各自的.asm，发现在程序1.asm中ar的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_BSS SEGMENT</span><br><span class="line">     ?ar@@<span class="number">3</span>PAHA DD <span class="number">0493e0</span><span class="function">H <span class="title">DUP</span> <span class="params">(?)</span>    </span>; ar</span><br><span class="line">_BSS ENDS</span><br></pre></td></tr></table></figure></p><p>而在程序2.asm中，ar被定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_DATA SEGMENT</span><br><span class="line">     ?ar@@<span class="number">3</span>PAHA DD <span class="number">01</span>H     ; ar</span><br><span class="line">                DD <span class="number">02</span>H</span><br><span class="line">                DD <span class="number">03</span>H</span><br><span class="line">                ORG $+<span class="number">1199988</span></span><br><span class="line">_DATA ENDS</span><br></pre></td></tr></table></figure><br>区别很明显，一个位于.bss段，而另一个位于.data段，两者的区别在于：全局的未初始化变量存在于.bss段中，具体体现为一个占位符；全局的已初始化变量存于.data段中；而函数内的自动变量都在栈上分配空间。</p><p>.bss是不占用.exe文件空间的，其内容由操作系统初始化（清零）；而.data却需要占用，其内容由程序初始化，因此造成了上述情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;ELF文件&quot;&gt;&lt;a href=&quot;#ELF文件&quot; class=&quot;headerlink&quot; title=&quot;ELF文件&quot;&gt;&lt;/a&gt;ELF文件&lt;/h4&gt;&lt;p&gt;在学习之前我们先看看ELF文件。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="http://tingyuxuan.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="计算机组成原理" scheme="http://tingyuxuan.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>一个程序在计算机中是如何运行的？</title>
    <link href="http://tingyuxuan.com/2019/11/03/%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9F/"/>
    <id>http://tingyuxuan.com/2019/11/03/一个程序在计算机中是如何运行的？/</id>
    <published>2019-11-03T05:17:58.000Z</published>
    <updated>2019-11-03T05:17:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于CPU来说，内存仅仅是一个存放指令和数据的地方，并不能在内存中完成计算功能，例如要计算 a = b + c，必须将 a、b、c 都读取到CPU内部才能进行加法运算。为了了解具体的运算过程，我们不妨先来看一下CPU的结构。运算单元是CPU的大脑，负责加减乘除、比较、位移等运算工作，每种运算都有对应的电路支持，速度很快。<br><a id="more"></a></p><h4 id="CPU运行示意"><a href="#CPU运行示意" class="headerlink" title="CPU运行示意"></a>CPU运行示意</h4><p><center><font face="楷体" size="4">图1 CPU是一个复杂的计算机部件，它内部又包含很多小零件，如下图所示：</font></center><br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106131858.png" alt></p><p>寄存器（Register）是CPU内部非常小、非常快速的存储部件，它的容量很有限，对于32位的CPU，每个寄存器一般能存储32位（4个字节）的数据，对于64位的CPU，每个寄存器一般能存储64位（8个字节）的数据。为了完成各种复杂的功能，现代CPU都内置了几十个甚至上百个的寄存器，嵌入式系统功能单一，寄存器数量较少。</p><p>我们经常听说多少位的CPU，指的就是寄存器的的位数。现在个人电脑使用的CPU已经进入了64位时代，例如 Intel 的 Core i3、i5、i7 等。</p><p>寄存器在程序的执行过程中至关重要，不可或缺，它们可以用来完成数学运算、控制循环次数、控制程序的执行流程、标记CPU运行状态等。例如，EIP（Extern Instruction Pointer ）寄存器的值是下一条指令的地址，CPU执行完当前指令后，会根据 EIP 的值找到下一条指令，改变 EIP 的值，就会改变程序的执行流程；CR3 寄存器保存着当前进程页目录的物理地址，切换进程就会改变 CR3 的值。</p><p>那么，在CPU内部为什么又要设置缓存呢？虽然内存的读取速度已经很快了，但是和CPU比起来，还是有很大差距的，不是一个数量级的，如果每次都从内存中读取数据，会严重拖慢CPU的运行速度，CPU经常处于等待状态，无事可做。在CPU内部设置一个缓存，可以将使用频繁的数据暂时读取到缓存，需要同一地址上的数据时，就不用大老远地再去访问内存，直接从缓存中读取即可。大家在购买CPU时，也会经常关心缓存容量，例如 Intel Core i7 3770K 的三级缓存为 8MB，二级缓存为 256KB，一级缓存为 32KB。容量越大，CPU越强悍。</p><p>缓存的容量是有限的，CPU只能从缓存中读取到部分数据，对于使用不是很频繁的数据，会绕过缓存，直接到内存中读取。所以不是每次都能从缓存中得到数据，这就是缓存的命中率，能够从缓存中读取就命中，否则就没命中。关于缓存的命中率又是一门学问，哪些数据保留在缓存，哪些数据不保留，都有复杂的算法。</p><h4 id="CPU指令"><a href="#CPU指令" class="headerlink" title="CPU指令"></a>CPU指令</h4><p>要想让CPU工作，必须借助特定的指令，例如 add 用于加法运算，sub 用于除法运算，cmp 用于比较两个数的大小，这称为CPU的指令集（Instruction Set）。我们的C语言代码最终也会编译成一条一条的CPU指令。不同型号的CPU支持的指令集会有所差异，但绝大部分是相同的。</p><p>我们以C语言中的加法为例来演示CPU指令的使用。假设有下面的C语言代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0X14</span>, b = <span class="number">0XAE</span>, c;</span><br><span class="line">c = a + b;</span><br></pre></td></tr></table></figure><br>在VS2010 Debug模式下生成的CPU指令为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov  ptr[a], <span class="number">0X14</span></span><br><span class="line">mov  ptr[b], <span class="number">0XAE</span></span><br><span class="line">mov  eax, ptr[a]</span><br><span class="line">add  eax, ptr[b]</span><br><span class="line">mov  ptr[c], eax</span><br></pre></td></tr></table></figure><br>mov 和 add 都是CPU指令：<br><strong>1.</strong>mov 用来将一个数值移动到一个存储位置。这个数值可以是一个常数，也可以在内存或者寄存器上；这个存储位置可以是寄存器或者内存。<br>第一条指令中，ptr[a]表示变量 a 的地址，0X14是一个数值，mov ptr[a], 0X14表示把数值 0X14 移动到 ptr[a] 指向的内存，也就是给变量 a 赋值。第二条指令与此类似。<br>第三条指令中，eax是寄存器的名字，该寄存器常用在加法运算中，用来保存某个加数或运算结果，mov eax, ptr[a]表示把变量 a 的值移动到寄存器 eax 中。<br>第五条指令表示把寄存器eax的值移动到变量c中，此时exa中的值为 a、b相加的和。</p><p><strong>2.</strong>add 用来将两个数值相加，这两个数值可以在寄存器或者内存中，add 会将相加的结果放在第一个数所在的位置。第四条指令add  eax, ptr[b]表示把 eax 和 ptr[a] 中的数值相加，并把结果放在 eax 中。</p><p>总起来讲：第一二条指令给变量 a、b 赋值，第三四条指令完成加法运算，第五条指令将运算结果赋值给变量c。实际上，上面的代码是汇编语言，不是CPU指令，汇编语言还要经过简单的转换才能成为CPU指令；为了更加容易地说明问题，这些语句也没有严格遵守汇编的语法。有兴趣的同学可以自行学习汇编语言，这里不再展开讲解。</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟内存到底是什么？为什么我们在C语言中看到的地址是假的？<br>在C语言中，指针变量的值就是一个内存地址，&amp;运算符的作用也是取变量的内存地址，<br>请看下面的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">255</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *pa = &amp;a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"pa = %#X, &amp;b = %#X\n"</span>, pa, &amp;b);</span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在 C-Free 5.0 下运行，结果为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pa = <span class="number">0X402000</span>, &amp;b = <span class="number">0X402004</span></span><br></pre></td></tr></table></figure><br>代码中的 a、b 是全局变量，它们的内存地址在链接时就已经决定了，以后再也不能改变，该程序无论在何时运行，结果都是一样的。</p><p>那么问题来了，如果物理内存中的这两个地址被其他程序占用了怎么办，我们的程序岂不是无法运行了？</p><p>幸运的是，这些内存地址都是假的，不是真实的物理内存地址，而是虚拟地址。虚拟地址通过CPU的转换才能对应到物理地址，而且每次程序运行时，操作系统都会重新安排虚拟地址和物理地址的对应关系，哪一段物理内存空闲就使用哪一段。如下图所示：<br><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106132522.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于CPU来说，内存仅仅是一个存放指令和数据的地方，并不能在内存中完成计算功能，例如要计算 a = b + c，必须将 a、b、c 都读取到CPU内部才能进行加法运算。为了了解具体的运算过程，我们不妨先来看一下CPU的结构。运算单元是CPU的大脑，负责加减乘除、比较、位移等运算工作，每种运算都有对应的电路支持，速度很快。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>载入内存，让程序运行起来</title>
    <link href="http://tingyuxuan.com/2019/11/02/%E8%BD%BD%E5%85%A5%E5%86%85%E5%AD%98%EF%BC%8C%E8%AE%A9%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5/"/>
    <id>http://tingyuxuan.com/2019/11/02/载入内存，让程序运行起来/</id>
    <published>2019-11-02T05:09:26.000Z</published>
    <updated>2019-11-02T05:09:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你的电脑上安装了QQ，你希望和好友聊天，会双击QQ图标，打开QQ软件，输入账号和密码，然后登录就可以了。那么，QQ是怎么运行起来的呢？<br><a id="more"></a><br>首先，有一点你要明确，你安装的QQ软件是保存在硬盘中的。<br>双击QQ图标，操作系统就会知道你要运行这个软件，它会在硬盘中找到你安装的QQ软件，将数据（安装的软件本质上就是很多数据的集合）复制到内存。对！就是复制到内存！QQ不是在硬盘中运行的，而是在内存中运行的。</p><p>为什么呢？因为内存的读写速度比硬盘快很多。<br>对于读写速度，内存 &gt; 固态硬盘 &gt; 机械硬盘。机械硬盘是靠电机带动盘片转动来读写数据的，而内存条通过电路来读写数据，电机的转速肯定没有电的传输速度（几乎是光速）快。虽然固态硬盘也是通过电路来读写数据，但是因为与内存的控制方式不一样，速度也不及内存。<br>所以，不管是运行QQ还是编辑Word文档，都是先将硬盘上的数据复制到内存，才能让CPU来处理，这个过程就叫作载入内存（Load into Memory）。完成这个过程需要一个特殊的程序（软件），这个程序就叫做加载器（Loader）。</p><p>CPU直接与内存打交道，它会读取内存中的数据进行处理，并将结果保存到内存。如果需要保存到硬盘，才会将内存中的数据复制到硬盘。</p><p>例如，打开Word文档，输入一些文字，虽然我们看到的不一样了，但是硬盘中的文档没有改变，新增的文字暂时保存到了内存，Ctrl+S才会保存到硬盘。因为内存断电后会丢失数据，所以如果你编辑完Word文档忘记保存就关机了，那么你将永远无法找回这些内容。</p><p>如果我们运行的程序较多，占用的空间就会超过内存（内存条）容量。例如计算机的内存容量为2G，却运行着10个程序，这10个程序共占用3G的空间，也就意味着需要从硬盘复制 3G 的数据到内存，这显然是不可能的。</p><p>操作系统（Operating System，简称 OS）为我们解决了这个问题：当程序运行需要的空间大于内存容量时，会将内存中暂时不用的数据再写回硬盘；需要这些数据时再从硬盘中读取，并将另外一部分不用的数据写入硬盘。这样，硬盘中就会有一部分空间用来存放内存中暂时不用的数据。这一部分空间就叫做虚拟内存（Virtual Memory）。<br>3G - 2G = 1G，上面的情况需要在硬盘上分配 1G 的虚拟内存。</p><p>硬盘的读写速度比内存慢很多，反复交换数据会消耗很多时间，所以如果你的内存太小，会严重影响计算机的运行速度，甚至会出现”卡死“现象，即使CPU强劲，也不会有大的改观。如果经济条件允许，建议将内存升级为 4G，在 win7、win8、win10 下运行软件就会比较流畅了。</p><font face="楷体" size="4">总结：CPU直接从内存中读取数据，处理完成后将结果再写入内存。</font><p><img src="https://kankan-myblog.oss-cn-shenzhen.aliyuncs.com/img/20191106131023.png" alt></p><center><font face="楷体" size="4">CPU、内存、硬盘和主板的关系。</font></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你的电脑上安装了QQ，你希望和好友聊天，会双击QQ图标，打开QQ软件，输入账号和密码，然后登录就可以了。那么，QQ是怎么运行起来的呢？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://tingyuxuan.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://tingyuxuan.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>vcpkg神器加速下载的方法</title>
    <link href="http://tingyuxuan.com/2019/10/20/vcpkg%E7%A5%9E%E5%99%A8%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://tingyuxuan.com/2019/10/20/vcpkg神器加速下载的方法/</id>
    <published>2019-10-20T03:39:20.000Z</published>
    <updated>2019-10-20T03:39:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>vcpkg是微软开发的c++语言第三方cpp库应用类似于pycharm中python模块的安装。vcpkg具有优良的特性安装cpp库并自动实现编译，编译之后在vs和vscode能直接使用引用头文件的方法使用第三方库中的文件。但是在第三方库的安装过程中由于网络原因会出现安装失败的情况。经过百度之后笔者发现使用下面的方法可以加速文件的安装：<br><a id="more"></a><br>在安装失败的界面拷贝安装失败的网络路径并使用浏览器下载或者迅雷软件下载到本地，下载完成后将下载到本地的唯洁雅文件拷贝到vcpkg文件夹下面的download界面如笔者的路径F:\vcpkg-2019.10\downloads然后在cmd下vcpkg install xxx即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vcpkg是微软开发的c++语言第三方cpp库应用类似于pycharm中python模块的安装。vcpkg具有优良的特性安装cpp库并自动实现编译，编译之后在vs和vscode能直接使用引用头文件的方法使用第三方库中的文件。但是在第三方库的安装过程中由于网络原因会出现安装失败的情况。经过百度之后笔者发现使用下面的方法可以加速文件的安装：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂项" scheme="http://tingyuxuan.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="杂项" scheme="http://tingyuxuan.com/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>C++中指向类成员的指针</title>
    <link href="http://tingyuxuan.com/2019/10/11/C-%E4%B8%AD%E6%8C%87%E5%90%91%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88/"/>
    <id>http://tingyuxuan.com/2019/10/11/C-中指向类成员的指针/</id>
    <published>2019-10-11T08:11:11.000Z</published>
    <updated>2019-10-11T08:11:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++语言中，可以定义一个指针，使其指向类成员或成员函数，然后通过指针来访问类的成员。这包括指向属性成员的指针和指向成员函数的指针。</p><a id="more"></a><h4 id="指向普通变量和函数的指针"><a href="#指向普通变量和函数的指针" class="headerlink" title="指向普通变量和函数的指针"></a>指向普通变量和函数的指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;<span class="comment">//指向普通变量的指针</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">int</span>) = func;<span class="comment">//函数指针的声明</span></span><br><span class="line">pf(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指向类数据成员的指针"><a href="#指向类数据成员的指针" class="headerlink" title="指向类数据成员的指针"></a>指向类数据成员的指针</h4><p><font face="楷体"> <strong>定义：</strong></font>&lt;数据类型&gt;&lt;类名&gt;::*&lt;指针名&gt;</p><p><font face="楷体"> <strong>赋值和初始化：</strong> </font>&lt;数据类型&gt;&lt;类名&gt;::*&lt;指针名&gt;[=&amp;&lt;类名&gt;::&lt;非静态数据成员&gt;]</p><p><font face="楷体"> <strong>注意：</strong></font>指向非静态数据成员的指针在定义时必须和类相关联，在使用时必须和具体的对象关联。</p><p><font face="楷体"> <strong>解引用：</strong> </font>由于类不是运行时 存在的对象。因此，在使用这类指针时，需要首先指定类的一个对象，然后，通过对象来引用指针所指向的成员。即</p><ul><li>&lt;类对象名&gt;.*&lt;指向非静态数据成员的指针&gt;</li><li>&lt;类对象指针&gt;-&gt;*&lt;指向非静态数据成员的指针&gt;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Student(<span class="built_in">string</span> n, <span class="keyword">int</span> nu) : name(n), num(nu) &#123;&#125;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Student <span class="title">s</span><span class="params">(<span class="string">"zhangsan"</span>, <span class="number">1002</span>)</span></span>;</span><br><span class="line"><span class="function">Student <span class="title">s2</span><span class="params">(<span class="string">"lisi"</span>, <span class="number">1001</span>)</span></span>;</span><br><span class="line"><span class="comment">// string *ps = &amp;s.name;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt; *ps&lt;&lt;endl;</span></span><br><span class="line"><span class="built_in">string</span> Student::*ps = &amp;Student::name;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.*ps &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2.*ps &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Student *pp = <span class="keyword">new</span> Student(<span class="string">"wangwu"</span>, <span class="number">1003</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pp-&gt;*ps &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指向类成员函数的指针"><a href="#指向类成员函数的指针" class="headerlink" title="指向类成员函数的指针"></a>指向类成员函数的指针</h4><p><font face="楷体"> <strong>注意：</strong></font>定义一个指向非静态成员函数的指针必须在三个方面与其指向的成员函数保持一致：参数列表要相同、返回类型要相同、所属的类型要相同</p><p><font face="楷体"> <strong>定义：</strong></font>&lt;数据类型&gt;(&lt;类名&gt;::*&lt;指针名&gt;)(&lt;参数列表&gt;)</p><p><font face="楷体"> <strong>赋值和初始化：</strong> </font>&lt;数据类型&gt;(&lt;类名&gt;::*&lt;指针名&gt;)(&lt;参数列表&gt;)[=&amp;&lt;类名&gt;::&lt;非静态成员函数&gt;]</p><p><font face="楷体"> <strong>解引用：</strong> </font>由于类不是运行时存在的对象。因此，在使用这类指针时，需要首先指定类的一个对象，然后，通过对象来引用指针所指向的成员。即</p><ul><li>(&lt;类对象名&gt;.*&lt;指向非静态成员函数的指针&gt;)(&lt;参数列表&gt;)</li><li>(&lt;类对象指针&gt;-&gt;*&lt;指向非静态成员函数的指针&gt;)(&lt;参数列表&gt;)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Student(<span class="built_in">string</span> n, <span class="keyword">int</span> nu) : name(n), num(nu) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"name "</span> &lt;&lt; name &lt;&lt; <span class="string">" num "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Student <span class="title">s</span><span class="params">(<span class="string">"zhangsan"</span>, <span class="number">1002</span>)</span></span>;</span><br><span class="line"><span class="function">Student <span class="title">s2</span><span class="params">(<span class="string">"lisi"</span>, <span class="number">1001</span>)</span></span>;</span><br><span class="line">Student *ps = <span class="keyword">new</span> Student(<span class="string">"lisi"</span>, <span class="number">1003</span>);</span><br><span class="line"><span class="keyword">void</span> (Student::*pf)() = &amp;Student::dis;</span><br><span class="line">(s.*pf)();</span><br><span class="line">(s2.*pf)();</span><br><span class="line">(ps-&gt;*pf)();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="指向类成员指针小结"><a href="#指向类成员指针小结" class="headerlink" title="指向类成员指针小结"></a>指向类成员指针小结</h5><p>与普通意义上的指针不一样。存放的是偏移量。1.指向非静态成员函数时，必须用类名作限定符，使用时则必须用类的实例作限定符。2.指向静态成员函数时，则不需要使用类名作限定符。</p><h5 id="应用提高——用指向类员函数的指针，实现更加隐蔽的接口"><a href="#应用提高——用指向类员函数的指针，实现更加隐蔽的接口" class="headerlink" title="应用提高——用指向类员函数的指针，实现更加隐蔽的接口"></a>应用提高——用指向类员函数的指针，实现更加隐蔽的接口</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Widget()</span><br><span class="line">&#123;</span><br><span class="line">fptr[<span class="number">0</span>] = &amp;f;</span><br><span class="line">fptr[<span class="number">1</span>] = &amp;g;</span><br><span class="line">fptr[<span class="number">2</span>] = &amp;h;</span><br><span class="line">fptr[<span class="number">3</span>] = &amp;i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx &lt; <span class="number">0</span> || idx &gt; cnt)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">(<span class="keyword">this</span>-&gt;*fptr[idx])(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"void f() "</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"void g() "</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"void h() "</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"void i() "</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">cnt = <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> (Widget::*fptr[cnt])(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.count(); i++)</span><br><span class="line">&#123;</span><br><span class="line">w.select(i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指向类静态成员的指针"><a href="#指向类静态成员的指针" class="headerlink" title="指向类静态成员的指针"></a>指向类静态成员的指针</h4><p>1.指向类静态数据成员的指针<br>指向静态数据成员的指针的定义和使用与普通指针相同，在定义时无须和类相关联，在使用时也无须和具体的对象相关联。</p><p>2.指向类静态成员函数的指针<br>指向静态成员函数的指针和普通指针相同，在定义时无须和类相关联，在使用时也无须和具体的对象相关联。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> A::dis()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A::data = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;A::data;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">void</span> (*pfunc)() = &amp;A::dis;</span><br><span class="line">pfunc();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 C++语言中，可以定义一个指针，使其指向类成员或成员函数，然后通过指针来访问类的成员。这包括指向属性成员的指针和指向成员函数的指针。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://tingyuxuan.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://tingyuxuan.com/tags/C/"/>
    
  </entry>
  
</feed>
